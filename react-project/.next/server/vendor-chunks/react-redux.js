'use strict';
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = 'vendor-chunks/react-redux';
exports.ids = ['vendor-chunks/react-redux'];
exports.modules = {
  /***/ '(ssr)/./node_modules/react-redux/dist/react-redux.mjs':
    /*!*******************************************************!*\
  !*** ./node_modules/react-redux/dist/react-redux.mjs ***!
  \*******************************************************/
    /***/ (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__,
    ) => {
      eval(
        'var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider_default),\n/* harmony export */   ReactReduxContext: () => (/* binding */ ReactReduxContext),\n/* harmony export */   batch: () => (/* binding */ batch),\n/* harmony export */   connect: () => (/* binding */ connect_default),\n/* harmony export */   createDispatchHook: () => (/* binding */ createDispatchHook),\n/* harmony export */   createSelectorHook: () => (/* binding */ createSelectorHook),\n/* harmony export */   createStoreHook: () => (/* binding */ createStoreHook),\n/* harmony export */   shallowEqual: () => (/* binding */ shallowEqual),\n/* harmony export */   useDispatch: () => (/* binding */ useDispatch),\n/* harmony export */   useSelector: () => (/* binding */ useSelector),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js");\n/* harmony import */ var use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/with-selector.js */ "(ssr)/./node_modules/use-sync-external-store/with-selector.js");\n// src/index.ts\n\n\n\n// src/utils/react.ts\n\nvar React =\n// prettier-ignore\n// @ts-ignore\n true ? react__WEBPACK_IMPORTED_MODULE_0__ : /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)));\n\n// src/components/Context.ts\nvar ContextKey = Symbol.for(`react-redux-context`);\nvar gT = typeof globalThis !== "undefined" ? globalThis : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */\n{};\nfunction getContext() {\n  if (!React.createContext) return {};\n  const contextMap = gT[ContextKey] ?? (gT[ContextKey] = /* @__PURE__ */new Map());\n  let realContext = contextMap.get(React.createContext);\n  if (!realContext) {\n    realContext = React.createContext(null);\n    if (true) {\n      realContext.displayName = "ReactRedux";\n    }\n    contextMap.set(React.createContext, realContext);\n  }\n  return realContext;\n}\nvar ReactReduxContext = /* @__PURE__ */getContext();\n\n// src/utils/useSyncExternalStore.ts\nvar notInitialized = () => {\n  throw new Error("uSES not initialized!");\n};\n\n// src/hooks/useReduxContext.ts\nfunction createReduxContextHook(context = ReactReduxContext) {\n  return function useReduxContext2() {\n    const contextValue = React.useContext(context);\n    if ( true && !contextValue) {\n      throw new Error("could not find react-redux context value; please ensure the component is wrapped in a <Provider>");\n    }\n    return contextValue;\n  };\n}\nvar useReduxContext = /* @__PURE__ */createReduxContextHook();\n\n// src/hooks/useSelector.ts\nvar useSyncExternalStoreWithSelector = notInitialized;\nvar initializeUseSelector = fn => {\n  useSyncExternalStoreWithSelector = fn;\n};\nvar refEquality = (a, b) => a === b;\nfunction createSelectorHook(context = ReactReduxContext) {\n  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);\n  const useSelector2 = (selector, equalityFnOrOptions = {}) => {\n    const {\n      equalityFn = refEquality,\n      devModeChecks = {}\n    } = typeof equalityFnOrOptions === "function" ? {\n      equalityFn: equalityFnOrOptions\n    } : equalityFnOrOptions;\n    if (true) {\n      if (!selector) {\n        throw new Error(`You must pass a selector to useSelector`);\n      }\n      if (typeof selector !== "function") {\n        throw new Error(`You must pass a function as a selector to useSelector`);\n      }\n      if (typeof equalityFn !== "function") {\n        throw new Error(`You must pass a function as an equality function to useSelector`);\n      }\n    }\n    const {\n      store,\n      subscription,\n      getServerState,\n      stabilityCheck,\n      identityFunctionCheck\n    } = useReduxContext2();\n    const firstRun = React.useRef(true);\n    const wrappedSelector = React.useCallback({\n      [selector.name](state) {\n        const selected = selector(state);\n        if (true) {\n          const {\n            identityFunctionCheck: finalIdentityFunctionCheck,\n            stabilityCheck: finalStabilityCheck\n          } = {\n            stabilityCheck,\n            identityFunctionCheck,\n            ...devModeChecks\n          };\n          if (finalStabilityCheck === "always" || finalStabilityCheck === "once" && firstRun.current) {\n            const toCompare = selector(state);\n            if (!equalityFn(selected, toCompare)) {\n              let stack = void 0;\n              try {\n                throw new Error();\n              } catch (e) {\n                ;\n                ({\n                  stack\n                } = e);\n              }\n              console.warn("Selector " + (selector.name || "unknown") + " returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization", {\n                state,\n                selected,\n                selected2: toCompare,\n                stack\n              });\n            }\n          }\n          if (finalIdentityFunctionCheck === "always" || finalIdentityFunctionCheck === "once" && firstRun.current) {\n            if (selected === state) {\n              let stack = void 0;\n              try {\n                throw new Error();\n              } catch (e) {\n                ;\n                ({\n                  stack\n                } = e);\n              }\n              console.warn("Selector " + (selector.name || "unknown") + " returned the root state when called. This can lead to unnecessary rerenders.\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.", {\n                stack\n              });\n            }\n          }\n          if (firstRun.current) firstRun.current = false;\n        }\n        return selected;\n      }\n    }[selector.name], [selector, stabilityCheck, devModeChecks.stabilityCheck]);\n    const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);\n    React.useDebugValue(selectedState);\n    return selectedState;\n  };\n  Object.assign(useSelector2, {\n    withTypes: () => useSelector2\n  });\n  return useSelector2;\n}\nvar useSelector = /* @__PURE__ */createSelectorHook();\n\n// src/utils/react-is.ts\nvar REACT_ELEMENT_TYPE = Symbol.for("react.element");\nvar REACT_PORTAL_TYPE = Symbol.for("react.portal");\nvar REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");\nvar REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");\nvar REACT_PROFILER_TYPE = Symbol.for("react.profiler");\nvar REACT_PROVIDER_TYPE = Symbol.for("react.provider");\nvar REACT_CONTEXT_TYPE = Symbol.for("react.context");\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");\nvar REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");\nvar REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");\nvar REACT_MEMO_TYPE = Symbol.for("react.memo");\nvar REACT_LAZY_TYPE = Symbol.for("react.lazy");\nvar REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");\nvar REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nfunction isValidElementType(type) {\n  if (typeof type === "string" || typeof type === "function") {\n    return true;\n  }\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE) {\n    return true;\n  }\n  if (typeof type === "object" && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||\n    // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don\'t know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction typeOf(object) {\n  if (typeof object === "object" && object !== null) {\n    const $$typeof = object.$$typeof;\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        {\n          const type = object.type;\n          switch (type) {\n            case REACT_FRAGMENT_TYPE:\n            case REACT_PROFILER_TYPE:\n            case REACT_STRICT_MODE_TYPE:\n            case REACT_SUSPENSE_TYPE:\n            case REACT_SUSPENSE_LIST_TYPE:\n              return type;\n            default:\n              {\n                const $$typeofType = type && type.$$typeof;\n                switch ($$typeofType) {\n                  case REACT_SERVER_CONTEXT_TYPE:\n                  case REACT_CONTEXT_TYPE:\n                  case REACT_FORWARD_REF_TYPE:\n                  case REACT_LAZY_TYPE:\n                  case REACT_MEMO_TYPE:\n                  case REACT_PROVIDER_TYPE:\n                    return $$typeofType;\n                  default:\n                    return $$typeof;\n                }\n              }\n          }\n        }\n      case REACT_PORTAL_TYPE:\n        {\n          return $$typeof;\n        }\n    }\n  }\n  return void 0;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\n\n// src/utils/warning.ts\nfunction warning(message) {\n  if (typeof console !== "undefined" && typeof console.error === "function") {\n    console.error(message);\n  }\n  try {\n    throw new Error(message);\n  } catch (e) {}\n}\n\n// src/connect/verifySubselectors.ts\nfunction verify(selector, methodName) {\n  if (!selector) {\n    throw new Error(`Unexpected value for ${methodName} in connect.`);\n  } else if (methodName === "mapStateToProps" || methodName === "mapDispatchToProps") {\n    if (!Object.prototype.hasOwnProperty.call(selector, "dependsOnOwnProps")) {\n      warning(`The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`);\n    }\n  }\n}\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {\n  verify(mapStateToProps, "mapStateToProps");\n  verify(mapDispatchToProps, "mapDispatchToProps");\n  verify(mergeProps, "mergeProps");\n}\n\n// src/connect/selectorFactory.ts\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, {\n  areStatesEqual,\n  areOwnPropsEqual,\n  areStatePropsEqual\n}) {\n  let hasRunAtLeastOnce = false;\n  let state;\n  let ownProps;\n  let stateProps;\n  let dispatchProps;\n  let mergedProps;\n  function handleFirstCall(firstState, firstOwnProps) {\n    state = firstState;\n    ownProps = firstOwnProps;\n    stateProps = mapStateToProps(state, ownProps);\n    dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    hasRunAtLeastOnce = true;\n    return mergedProps;\n  }\n  function handleNewPropsAndNewState() {\n    stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleNewProps() {\n    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleNewState() {\n    const nextStateProps = mapStateToProps(state, ownProps);\n    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n    stateProps = nextStateProps;\n    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleSubsequentCalls(nextState, nextOwnProps) {\n    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n    const stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);\n    state = nextState;\n    ownProps = nextOwnProps;\n    if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n    if (propsChanged) return handleNewProps();\n    if (stateChanged) return handleNewState();\n    return mergedProps;\n  }\n  return function pureFinalPropsSelector(nextState, nextOwnProps) {\n    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n  };\n}\nfunction finalPropsSelectorFactory(dispatch, {\n  initMapStateToProps,\n  initMapDispatchToProps,\n  initMergeProps,\n  ...options\n}) {\n  const mapStateToProps = initMapStateToProps(dispatch, options);\n  const mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n  const mergeProps = initMergeProps(dispatch, options);\n  if (true) {\n    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);\n  }\n  return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}\n\n// src/utils/bindActionCreators.ts\nfunction bindActionCreators(actionCreators, dispatch) {\n  const boundActionCreators = {};\n  for (const key in actionCreators) {\n    const actionCreator = actionCreators[key];\n    if (typeof actionCreator === "function") {\n      boundActionCreators[key] = (...args) => dispatch(actionCreator(...args));\n    }\n  }\n  return boundActionCreators;\n}\n\n// src/utils/isPlainObject.ts\nfunction isPlainObject(obj) {\n  if (typeof obj !== "object" || obj === null) return false;\n  const proto = Object.getPrototypeOf(obj);\n  if (proto === null) return true;\n  let baseProto = proto;\n  while (Object.getPrototypeOf(baseProto) !== null) {\n    baseProto = Object.getPrototypeOf(baseProto);\n  }\n  return proto === baseProto;\n}\n\n// src/utils/verifyPlainObject.ts\nfunction verifyPlainObject(value, displayName, methodName) {\n  if (!isPlainObject(value)) {\n    warning(`${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`);\n  }\n}\n\n// src/connect/wrapMapToProps.ts\nfunction wrapMapToPropsConstant(getConstant) {\n  return function initConstantSelector(dispatch) {\n    const constant = getConstant(dispatch);\n    function constantSelector() {\n      return constant;\n    }\n    constantSelector.dependsOnOwnProps = false;\n    return constantSelector;\n  };\n}\nfunction getDependsOnOwnProps(mapToProps) {\n  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n}\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n  return function initProxySelector(dispatch, {\n    displayName\n  }) {\n    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);\n    };\n    proxy.dependsOnOwnProps = true;\n    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n      proxy.mapToProps = mapToProps;\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n      let props = proxy(stateOrDispatch, ownProps);\n      if (typeof props === "function") {\n        proxy.mapToProps = props;\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n        props = proxy(stateOrDispatch, ownProps);\n      }\n      if (true) verifyPlainObject(props, displayName, methodName);\n      return props;\n    };\n    return proxy;\n  };\n}\n\n// src/connect/invalidArgFactory.ts\nfunction createInvalidArgFactory(arg, name) {\n  return (dispatch, options) => {\n    throw new Error(`Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`);\n  };\n}\n\n// src/connect/mapDispatchToProps.ts\nfunction mapDispatchToPropsFactory(mapDispatchToProps) {\n  return mapDispatchToProps && typeof mapDispatchToProps === "object" ? wrapMapToPropsConstant(dispatch =>\n  // @ts-ignore\n  bindActionCreators(mapDispatchToProps, dispatch)) : !mapDispatchToProps ? wrapMapToPropsConstant(dispatch => ({\n    dispatch\n  })) : typeof mapDispatchToProps === "function" ?\n  // @ts-ignore\n  wrapMapToPropsFunc(mapDispatchToProps, "mapDispatchToProps") : createInvalidArgFactory(mapDispatchToProps, "mapDispatchToProps");\n}\n\n// src/connect/mapStateToProps.ts\nfunction mapStateToPropsFactory(mapStateToProps) {\n  return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : typeof mapStateToProps === "function" ?\n  // @ts-ignore\n  wrapMapToPropsFunc(mapStateToProps, "mapStateToProps") : createInvalidArgFactory(mapStateToProps, "mapStateToProps");\n}\n\n// src/connect/mergeProps.ts\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n  return {\n    ...ownProps,\n    ...stateProps,\n    ...dispatchProps\n  };\n}\nfunction wrapMergePropsFunc(mergeProps) {\n  return function initMergePropsProxy(dispatch, {\n    displayName,\n    areMergedPropsEqual\n  }) {\n    let hasRunOnce = false;\n    let mergedProps;\n    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n      if (hasRunOnce) {\n        if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;\n      } else {\n        hasRunOnce = true;\n        mergedProps = nextMergedProps;\n        if (true) verifyPlainObject(mergedProps, displayName, "mergeProps");\n      }\n      return mergedProps;\n    };\n  };\n}\nfunction mergePropsFactory(mergeProps) {\n  return !mergeProps ? () => defaultMergeProps : typeof mergeProps === "function" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, "mergeProps");\n}\n\n// src/utils/batch.ts\nfunction defaultNoopBatch(callback) {\n  callback();\n}\n\n// src/utils/Subscription.ts\nfunction createListenerCollection() {\n  let first = null;\n  let last = null;\n  return {\n    clear() {\n      first = null;\n      last = null;\n    },\n    notify() {\n      defaultNoopBatch(() => {\n        let listener = first;\n        while (listener) {\n          listener.callback();\n          listener = listener.next;\n        }\n      });\n    },\n    get() {\n      const listeners = [];\n      let listener = first;\n      while (listener) {\n        listeners.push(listener);\n        listener = listener.next;\n      }\n      return listeners;\n    },\n    subscribe(callback) {\n      let isSubscribed = true;\n      const listener = last = {\n        callback,\n        next: null,\n        prev: last\n      };\n      if (listener.prev) {\n        listener.prev.next = listener;\n      } else {\n        first = listener;\n      }\n      return function unsubscribe() {\n        if (!isSubscribed || first === null) return;\n        isSubscribed = false;\n        if (listener.next) {\n          listener.next.prev = listener.prev;\n        } else {\n          last = listener.prev;\n        }\n        if (listener.prev) {\n          listener.prev.next = listener.next;\n        } else {\n          first = listener.next;\n        }\n      };\n    }\n  };\n}\nvar nullListeners = {\n  notify() {},\n  get: () => []\n};\nfunction createSubscription(store, parentSub) {\n  let unsubscribe;\n  let listeners = nullListeners;\n  let subscriptionsAmount = 0;\n  let selfSubscribed = false;\n  function addNestedSub(listener) {\n    trySubscribe();\n    const cleanupListener = listeners.subscribe(listener);\n    let removed = false;\n    return () => {\n      if (!removed) {\n        removed = true;\n        cleanupListener();\n        tryUnsubscribe();\n      }\n    };\n  }\n  function notifyNestedSubs() {\n    listeners.notify();\n  }\n  function handleChangeWrapper() {\n    if (subscription.onStateChange) {\n      subscription.onStateChange();\n    }\n  }\n  function isSubscribed() {\n    return selfSubscribed;\n  }\n  function trySubscribe() {\n    subscriptionsAmount++;\n    if (!unsubscribe) {\n      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n      listeners = createListenerCollection();\n    }\n  }\n  function tryUnsubscribe() {\n    subscriptionsAmount--;\n    if (unsubscribe && subscriptionsAmount === 0) {\n      unsubscribe();\n      unsubscribe = void 0;\n      listeners.clear();\n      listeners = nullListeners;\n    }\n  }\n  function trySubscribeSelf() {\n    if (!selfSubscribed) {\n      selfSubscribed = true;\n      trySubscribe();\n    }\n  }\n  function tryUnsubscribeSelf() {\n    if (selfSubscribed) {\n      selfSubscribed = false;\n      tryUnsubscribe();\n    }\n  }\n  const subscription = {\n    addNestedSub,\n    notifyNestedSubs,\n    handleChangeWrapper,\n    isSubscribed,\n    trySubscribe: trySubscribeSelf,\n    tryUnsubscribe: tryUnsubscribeSelf,\n    getListeners: () => listeners\n  };\n  return subscription;\n}\n\n// src/utils/useIsomorphicLayoutEffect.ts\nvar canUseDOM = !!( false && 0);\nvar isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";\nvar useIsomorphicLayoutEffect = canUseDOM || isReactNative ? React.useLayoutEffect : React.useEffect;\n\n// src/utils/shallowEqual.ts\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) return true;\n  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return false;\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// src/utils/hoistStatics.ts\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  $$typeof: true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  $$typeof: true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = {\n  [ForwardRef]: FORWARD_REF_STATICS,\n  [Memo]: MEMO_STATICS\n};\nfunction getStatics(component) {\n  if (isMemo(component)) {\n    return MEMO_STATICS;\n  }\n  return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;\n}\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent) {\n  if (typeof sourceComponent !== "string") {\n    if (objectPrototype) {\n      const inheritedComponent = getPrototypeOf(sourceComponent);\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent);\n      }\n    }\n    let keys = getOwnPropertyNames(sourceComponent);\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n    const targetStatics = getStatics(targetComponent);\n    const sourceStatics = getStatics(sourceComponent);\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        const descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n        try {\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {}\n      }\n    }\n  }\n  return targetComponent;\n}\n\n// src/components/connect.tsx\nvar useSyncExternalStore = notInitialized;\nvar initializeConnect = fn => {\n  useSyncExternalStore = fn;\n};\nvar NO_SUBSCRIPTION_ARRAY = [null, null];\nvar stringifyComponent = Comp => {\n  try {\n    return JSON.stringify(Comp);\n  } catch (err) {\n    return String(Comp);\n  }\n};\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n  useIsomorphicLayoutEffect(() => effectFunc(...effectArgs), dependencies);\n}\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {\n  lastWrapperProps.current = wrapperProps;\n  renderIsScheduled.current = false;\n  if (childPropsFromStoreUpdate.current) {\n    childPropsFromStoreUpdate.current = null;\n    notifyNestedSubs();\n  }\n}\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {\n  if (!shouldHandleStateChanges) return () => {};\n  let didUnsubscribe = false;\n  let lastThrownError = null;\n  const checkForUpdates = () => {\n    if (didUnsubscribe || !isMounted.current) {\n      return;\n    }\n    const latestStoreState = store.getState();\n    let newChildProps, error;\n    try {\n      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);\n    } catch (e) {\n      error = e;\n      lastThrownError = e;\n    }\n    if (!error) {\n      lastThrownError = null;\n    }\n    if (newChildProps === lastChildProps.current) {\n      if (!renderIsScheduled.current) {\n        notifyNestedSubs();\n      }\n    } else {\n      lastChildProps.current = newChildProps;\n      childPropsFromStoreUpdate.current = newChildProps;\n      renderIsScheduled.current = true;\n      additionalSubscribeListener();\n    }\n  };\n  subscription.onStateChange = checkForUpdates;\n  subscription.trySubscribe();\n  checkForUpdates();\n  const unsubscribeWrapper = () => {\n    didUnsubscribe = true;\n    subscription.tryUnsubscribe();\n    subscription.onStateChange = null;\n    if (lastThrownError) {\n      throw lastThrownError;\n    }\n  };\n  return unsubscribeWrapper;\n}\nfunction strictEqual(a, b) {\n  return a === b;\n}\nvar hasWarnedAboutDeprecatedPureOption = false;\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps, {\n  // The `pure` option has been removed, so TS doesn\'t like us destructuring this to check its existence.\n  // @ts-ignore\n  pure,\n  areStatesEqual = strictEqual,\n  areOwnPropsEqual = shallowEqual,\n  areStatePropsEqual = shallowEqual,\n  areMergedPropsEqual = shallowEqual,\n  // use React\'s forwardRef to expose a ref of the wrapped component\n  forwardRef = false,\n  // the context consumer to use\n  context = ReactReduxContext\n} = {}) {\n  if (true) {\n    if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {\n      hasWarnedAboutDeprecatedPureOption = true;\n      warning(\'The `pure` option has been removed. `connect` is now always a "pure/memoized" component\');\n    }\n  }\n  const Context = context;\n  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);\n  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);\n  const initMergeProps = mergePropsFactory(mergeProps);\n  const shouldHandleStateChanges = Boolean(mapStateToProps);\n  const wrapWithConnect = WrappedComponent => {\n    if (true) {\n      const isValid = /* @__PURE__ */isValidElementType(WrappedComponent);\n      if (!isValid) throw new Error(`You must pass a component to the function returned by connect. Instead received ${stringifyComponent(WrappedComponent)}`);\n    }\n    const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";\n    const displayName = `Connect(${wrappedComponentName})`;\n    const selectorFactoryOptions = {\n      shouldHandleStateChanges,\n      displayName,\n      wrappedComponentName,\n      WrappedComponent,\n      // @ts-ignore\n      initMapStateToProps,\n      // @ts-ignore\n      initMapDispatchToProps,\n      initMergeProps,\n      areStatesEqual,\n      areStatePropsEqual,\n      areOwnPropsEqual,\n      areMergedPropsEqual\n    };\n    function ConnectFunction(props) {\n      const [propsContext, reactReduxForwardedRef, wrapperProps] = React.useMemo(() => {\n        const {\n          reactReduxForwardedRef: reactReduxForwardedRef2,\n          ...wrapperProps2\n        } = props;\n        return [props.context, reactReduxForwardedRef2, wrapperProps2];\n      }, [props]);\n      const ContextToUse = React.useMemo(() => {\n        let ResultContext = Context;\n        if (propsContext?.Consumer) {\n          if (true) {\n            const isValid = /* @__PURE__ */isContextConsumer(\n            // @ts-ignore\n            /* @__PURE__ */\n            React.createElement(propsContext.Consumer, null));\n            if (!isValid) {\n              throw new Error("You must pass a valid React context consumer as `props.context`");\n            }\n            ResultContext = propsContext;\n          }\n        }\n        return ResultContext;\n      }, [propsContext, Context]);\n      const contextValue = React.useContext(ContextToUse);\n      const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n      const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n      if ( true && !didStoreComeFromProps && !didStoreComeFromContext) {\n        throw new Error(`Could not find "store" in the context of "${displayName}". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${displayName} in connect options.`);\n      }\n      const store = didStoreComeFromProps ? props.store : contextValue.store;\n      const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\n      const childPropsSelector = React.useMemo(() => {\n        return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);\n      }, [store]);\n      const [subscription, notifyNestedSubs] = React.useMemo(() => {\n        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;\n        const subscription2 = createSubscription(store, didStoreComeFromProps ? void 0 : contextValue.subscription);\n        const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);\n        return [subscription2, notifyNestedSubs2];\n      }, [store, didStoreComeFromProps, contextValue]);\n      const overriddenContextValue = React.useMemo(() => {\n        if (didStoreComeFromProps) {\n          return contextValue;\n        }\n        return {\n          ...contextValue,\n          subscription\n        };\n      }, [didStoreComeFromProps, contextValue, subscription]);\n      const lastChildProps = React.useRef(void 0);\n      const lastWrapperProps = React.useRef(wrapperProps);\n      const childPropsFromStoreUpdate = React.useRef(void 0);\n      const renderIsScheduled = React.useRef(false);\n      const isMounted = React.useRef(false);\n      const latestSubscriptionCallbackError = React.useRef(void 0);\n      useIsomorphicLayoutEffect(() => {\n        isMounted.current = true;\n        return () => {\n          isMounted.current = false;\n        };\n      }, []);\n      const actualChildPropsSelector = React.useMemo(() => {\n        const selector = () => {\n          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n            return childPropsFromStoreUpdate.current;\n          }\n          return childPropsSelector(store.getState(), wrapperProps);\n        };\n        return selector;\n      }, [store, wrapperProps]);\n      const subscribeForReact = React.useMemo(() => {\n        const subscribe = reactListener => {\n          if (!subscription) {\n            return () => {};\n          }\n          return subscribeUpdates(shouldHandleStateChanges, store, subscription,\n          // @ts-ignore\n          childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);\n        };\n        return subscribe;\n      }, [subscription]);\n      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs]);\n      let actualChildProps;\n      try {\n        actualChildProps = useSyncExternalStore(\n        // TODO We\'re passing through a big wrapper that does a bunch of extra side effects besides subscribing\n        subscribeForReact,\n        // TODO This is incredibly hacky. We\'ve already processed the store update and calculated new child props,\n        // TODO and we\'re just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n        actualChildPropsSelector, getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector);\n      } catch (err) {\n        if (latestSubscriptionCallbackError.current) {\n          ;\n          err.message += `\nThe error may be correlated with this previous error:\n${latestSubscriptionCallbackError.current.stack}\n\n`;\n        }\n        throw err;\n      }\n      useIsomorphicLayoutEffect(() => {\n        latestSubscriptionCallbackError.current = void 0;\n        childPropsFromStoreUpdate.current = void 0;\n        lastChildProps.current = actualChildProps;\n      });\n      const renderedWrappedComponent = React.useMemo(() => {\n        return (\n          // @ts-ignore\n          /* @__PURE__ */\n          React.createElement(WrappedComponent, {\n            ...actualChildProps,\n            ref: reactReduxForwardedRef\n          })\n        );\n      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);\n      const renderedChild = React.useMemo(() => {\n        if (shouldHandleStateChanges) {\n          return /* @__PURE__ */React.createElement(ContextToUse.Provider, {\n            value: overriddenContextValue\n          }, renderedWrappedComponent);\n        }\n        return renderedWrappedComponent;\n      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);\n      return renderedChild;\n    }\n    const _Connect = React.memo(ConnectFunction);\n    const Connect = _Connect;\n    Connect.WrappedComponent = WrappedComponent;\n    Connect.displayName = ConnectFunction.displayName = displayName;\n    if (forwardRef) {\n      const _forwarded = React.forwardRef(function forwardConnectRef(props, ref) {\n        return /* @__PURE__ */React.createElement(Connect, {\n          ...props,\n          reactReduxForwardedRef: ref\n        });\n      });\n      const forwarded = _forwarded;\n      forwarded.displayName = displayName;\n      forwarded.WrappedComponent = WrappedComponent;\n      return /* @__PURE__ */hoistNonReactStatics(forwarded, WrappedComponent);\n    }\n    return /* @__PURE__ */hoistNonReactStatics(Connect, WrappedComponent);\n  };\n  return wrapWithConnect;\n}\nvar connect_default = connect;\n\n// src/components/Provider.tsx\nfunction Provider({\n  store,\n  context,\n  children,\n  serverState,\n  stabilityCheck = "once",\n  identityFunctionCheck = "once"\n}) {\n  const contextValue = React.useMemo(() => {\n    const subscription = createSubscription(store);\n    return {\n      store,\n      subscription,\n      getServerState: serverState ? () => serverState : void 0,\n      stabilityCheck,\n      identityFunctionCheck\n    };\n  }, [store, serverState, stabilityCheck, identityFunctionCheck]);\n  const previousState = React.useMemo(() => store.getState(), [store]);\n  useIsomorphicLayoutEffect(() => {\n    const {\n      subscription\n    } = contextValue;\n    subscription.onStateChange = subscription.notifyNestedSubs;\n    subscription.trySubscribe();\n    if (previousState !== store.getState()) {\n      subscription.notifyNestedSubs();\n    }\n    return () => {\n      subscription.tryUnsubscribe();\n      subscription.onStateChange = void 0;\n    };\n  }, [contextValue, previousState]);\n  const Context = context || ReactReduxContext;\n  return /* @__PURE__ */React.createElement(Context.Provider, {\n    value: contextValue\n  }, children);\n}\nvar Provider_default = Provider;\n\n// src/hooks/useStore.ts\nfunction createStoreHook(context = ReactReduxContext) {\n  const useReduxContext2 = context === ReactReduxContext ? useReduxContext :\n  // @ts-ignore\n  createReduxContextHook(context);\n  const useStore2 = () => {\n    const {\n      store\n    } = useReduxContext2();\n    return store;\n  };\n  Object.assign(useStore2, {\n    withTypes: () => useStore2\n  });\n  return useStore2;\n}\nvar useStore = /* @__PURE__ */createStoreHook();\n\n// src/hooks/useDispatch.ts\nfunction createDispatchHook(context = ReactReduxContext) {\n  const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);\n  const useDispatch2 = () => {\n    const store = useStore2();\n    return store.dispatch;\n  };\n  Object.assign(useDispatch2, {\n    withTypes: () => useDispatch2\n  });\n  return useDispatch2;\n}\nvar useDispatch = /* @__PURE__ */createDispatchHook();\n\n// src/exports.ts\nvar batch = defaultNoopBatch;\n\n// src/index.ts\ninitializeUseSelector(use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector);\ninitializeConnect(react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZGlzdC9yZWFjdC1yZWR1eC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNnQztBQUNpRzs7QUFFakk7QUFDdUM7QUFDdkMsSUFBSUksS0FBSztBQUNQO0FBQ0E7QUFDQSxLQUEwQixHQUFHRCxrQ0FBd0IsR0FBR0EseUxBQ3pEOztBQUVEO0FBQ0EsSUFBSUUsVUFBVSxHQUFHQyxNQUFNLENBQUNDLEdBQUcsQ0FBRSxxQkFBb0IsQ0FBQztBQUNsRCxJQUFJQyxFQUFFLEdBQUcsT0FBT0MsVUFBVSxLQUFLLFdBQVcsR0FBR0EsVUFBVSxHQUNyRDtBQUNBLENBQUMsQ0FDRjtBQUNELFNBQVNDLFVBQVVBLENBQUEsRUFBRztFQUNwQixJQUFJLENBQUNOLEtBQUssQ0FBQ08sYUFBYSxFQUN0QixPQUFPLENBQUMsQ0FBQztFQUNYLE1BQU1DLFVBQVUsR0FBR0osRUFBRSxDQUFDSCxVQUFVLENBQUMsS0FBS0csRUFBRSxDQUFDSCxVQUFVLENBQUMsR0FBRyxlQUFnQixJQUFJUSxHQUFHLENBQUMsQ0FBQyxDQUFDO0VBQ2pGLElBQUlDLFdBQVcsR0FBR0YsVUFBVSxDQUFDRyxHQUFHLENBQUNYLEtBQUssQ0FBQ08sYUFBYSxDQUFDO0VBQ3JELElBQUksQ0FBQ0csV0FBVyxFQUFFO0lBQ2hCQSxXQUFXLEdBQUdWLEtBQUssQ0FBQ08sYUFBYSxDQUMvQixJQUNGLENBQUM7SUFDRCxJQUFJLE1BQXVDO01BQ3pDRyxXQUFXLENBQUNFLFdBQVcsR0FBRyxZQUFZO0lBQ3hDO0lBQ0FKLFVBQVUsQ0FBQ0ssR0FBRyxDQUFDYixLQUFLLENBQUNPLGFBQWEsRUFBRUcsV0FBVyxDQUFDO0VBQ2xEO0VBQ0EsT0FBT0EsV0FBVztBQUNwQjtBQUNBLElBQUlJLGlCQUFpQixHQUFHLGVBQWdCUixVQUFVLENBQUMsQ0FBQzs7QUFFcEQ7QUFDQSxJQUFJUyxjQUFjLEdBQUdBLENBQUEsS0FBTTtFQUN6QixN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QU1pUjtFQUNuQixDQUFDLENBQUM7RUFDRixPQUFPQSxTQUFTO0FBQ2xCO0FBQ0EsSUFBSUMsUUFBUSxHQUFHLGVBQWdCRixlQUFlLENBQUMsQ0FBQzs7QUFFaEQ7QUFDQSxTQUFTRyxrQkFBa0JBLENBQUM5VCxPQUFPLEdBQUdKLGlCQUFpQixFQUFFO0VBQ3ZELE1BQU1nVSxTQUFTLEdBQUc1VCxPQUFPLEtBQUtKLGlCQUFpQixHQUFHaVUsUUFBUSxHQUFHRixlQUFlLENBQUMzVCxPQUFPLENBQUM7RUFDckYsTUFBTStULFlBQVksR0FBR0EsQ0FBQSxLQUFNO0lBQ3pCLE1BQU0vUyxLQUFLLEdBQUc0UyxTQUFTLENBQUMsQ0FBQztJQUN6QixPQUFPNVMsS0FBSyxDQUFDb0UsUUFBUTtFQUN2QixDQUFDO0VBQ0QzQyxNQUFNLENBQUNDLE1BQU0sQ0FBQ3FSLFlBQVksRUFBRTtJQUMxQnBSLFNBQVMsRUFBRUEsQ0FBQSxLQUFNb1I7RUFDbkIsQ0FBQyxDQUFDO0VBQ0YsT0FBT0EsWUFBWTtBQUNyQjtBQUNBLElBQUlDLFdBQVcsR0FBRyxlQUFnQkYsa0JBQWtCLENBQUMsQ0FBQzs7QUFFdEQ7QUFDQSxJQUFJRyxLQUFLLEdBQUd0SyxnQkFBZ0I7O0FBRTVCO0FBQ0F0SixxQkFBcUIsQ0FBQ3pCLHNHQUFpQyxDQUFDO0FBQ3hEcVEsaUJBQWlCLENBQUN2USx1REFBMkIsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LXByb2plY3QvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZGlzdC9yZWFjdC1yZWR1eC5tanM/MDQyMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmltcG9ydCAqIGFzIFJlYWN0MiBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMiB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS93aXRoLXNlbGVjdG9yLmpzXCI7XG5cbi8vIHNyYy91dGlscy9yZWFjdC50c1xuaW1wb3J0ICogYXMgUmVhY3RPcmlnaW5hbCBmcm9tIFwicmVhY3RcIjtcbnZhciBSZWFjdCA9IChcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIC8vIEB0cy1pZ25vcmVcbiAgXCJkZWZhdWx0XCIgaW4gUmVhY3RPcmlnaW5hbCA/IFJlYWN0T3JpZ2luYWxbXCJkZWZhdWx0XCJdIDogUmVhY3RPcmlnaW5hbFxuKTtcblxuLy8gc3JjL2NvbXBvbmVudHMvQ29udGV4dC50c1xudmFyIENvbnRleHRLZXkgPSBTeW1ib2wuZm9yKGByZWFjdC1yZWR1eC1jb250ZXh0YCk7XG52YXIgZ1QgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiAoXG4gIC8qIGZhbGwgYmFjayB0byBhIHBlci1tb2R1bGUgc2NvcGUgKHByZS04LjEgYmVoYXZpb3VyKSBpZiBgZ2xvYmFsVGhpc2AgaXMgbm90IGF2YWlsYWJsZSAqL1xuICB7fVxuKTtcbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIGlmICghUmVhY3QuY3JlYXRlQ29udGV4dClcbiAgICByZXR1cm4ge307XG4gIGNvbnN0IGNvbnRleHRNYXAgPSBnVFtDb250ZXh0S2V5XSA/PyAoZ1RbQ29udGV4dEtleV0gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgbGV0IHJlYWxDb250ZXh0ID0gY29udGV4dE1hcC5nZXQoUmVhY3QuY3JlYXRlQ29udGV4dCk7XG4gIGlmICghcmVhbENvbnRleHQpIHtcbiAgICByZWFsQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoXG4gICAgICBudWxsXG4gICAgKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZWFsQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUmVhY3RSZWR1eFwiO1xuICAgIH1cbiAgICBjb250ZXh0TWFwLnNldChSZWFjdC5jcmVhdGVDb250ZXh0LCByZWFsQ29udGV4dCk7XG4gIH1cbiAgcmV0dXJuIHJlYWxDb250ZXh0O1xufVxudmFyIFJlYWN0UmVkdXhDb250ZXh0ID0gLyogQF9fUFVSRV9fICovIGdldENvbnRleHQoKTtcblxuLy8gc3JjL3V0aWxzL3VzZVN5bmNFeHRlcm5hbFN0b3JlLnRzXG52YXIgbm90SW5pdGlhbGl6ZWQgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcInVTRVMgbm90IGluaXRpYWxpemVkIVwiKTtcbn07XG5cbi8vIHNyYy9ob29rcy91c2VSZWR1eENvbnRleHQudHNcbmZ1bmN0aW9uIGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiB1c2VSZWR1eENvbnRleHQyKCkge1xuICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoY29udGV4dCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhY29udGV4dFZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiY291bGQgbm90IGZpbmQgcmVhY3QtcmVkdXggY29udGV4dCB2YWx1ZTsgcGxlYXNlIGVuc3VyZSB0aGUgY29tcG9uZW50IGlzIHdyYXBwZWQgaW4gYSA8UHJvdmlkZXI+XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0VmFsdWU7XG4gIH07XG59XG52YXIgdXNlUmVkdXhDb250ZXh0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soKTtcblxuLy8gc3JjL2hvb2tzL3VzZVNlbGVjdG9yLnRzXG52YXIgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSBub3RJbml0aWFsaXplZDtcbnZhciBpbml0aWFsaXplVXNlU2VsZWN0b3IgPSAoZm4pID0+IHtcbiAgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSBmbjtcbn07XG52YXIgcmVmRXF1YWxpdHkgPSAoYSwgYikgPT4gYSA9PT0gYjtcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9ySG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgY29uc3QgdXNlUmVkdXhDb250ZXh0MiA9IGNvbnRleHQgPT09IFJlYWN0UmVkdXhDb250ZXh0ID8gdXNlUmVkdXhDb250ZXh0IDogY3JlYXRlUmVkdXhDb250ZXh0SG9vayhjb250ZXh0KTtcbiAgY29uc3QgdXNlU2VsZWN0b3IyID0gKHNlbGVjdG9yLCBlcXVhbGl0eUZuT3JPcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCB7IGVxdWFsaXR5Rm4gPSByZWZFcXVhbGl0eSwgZGV2TW9kZUNoZWNrcyA9IHt9IH0gPSB0eXBlb2YgZXF1YWxpdHlGbk9yT3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiID8geyBlcXVhbGl0eUZuOiBlcXVhbGl0eUZuT3JPcHRpb25zIH0gOiBlcXVhbGl0eUZuT3JPcHRpb25zO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBwYXNzIGEgc2VsZWN0b3IgdG8gdXNlU2VsZWN0b3JgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBhIHNlbGVjdG9yIHRvIHVzZVNlbGVjdG9yYCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVxdWFsaXR5Rm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBhbiBlcXVhbGl0eSBmdW5jdGlvbiB0byB1c2VTZWxlY3RvcmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3RvcmUsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBnZXRTZXJ2ZXJTdGF0ZSxcbiAgICAgIHN0YWJpbGl0eUNoZWNrLFxuICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrXG4gICAgfSA9IHVzZVJlZHV4Q29udGV4dDIoKTtcbiAgICBjb25zdCBmaXJzdFJ1biA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgIHtcbiAgICAgICAgW3NlbGVjdG9yLm5hbWVdKHN0YXRlKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2s6IGZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrLFxuICAgICAgICAgICAgICBzdGFiaWxpdHlDaGVjazogZmluYWxTdGFiaWxpdHlDaGVja1xuICAgICAgICAgICAgfSA9IHtcbiAgICAgICAgICAgICAgc3RhYmlsaXR5Q2hlY2ssXG4gICAgICAgICAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVjayxcbiAgICAgICAgICAgICAgLi4uZGV2TW9kZUNoZWNrc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChmaW5hbFN0YWJpbGl0eUNoZWNrID09PSBcImFsd2F5c1wiIHx8IGZpbmFsU3RhYmlsaXR5Q2hlY2sgPT09IFwib25jZVwiICYmIGZpcnN0UnVuLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgY29uc3QgdG9Db21wYXJlID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgICAgICAgICAgICBpZiAoIWVxdWFsaXR5Rm4oc2VsZWN0ZWQsIHRvQ29tcGFyZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhY2sgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICh7IHN0YWNrIH0gPSBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgXCJTZWxlY3RvciBcIiArIChzZWxlY3Rvci5uYW1lIHx8IFwidW5rbm93blwiKSArIFwiIHJldHVybmVkIGEgZGlmZmVyZW50IHJlc3VsdCB3aGVuIGNhbGxlZCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMuIFRoaXMgY2FuIGxlYWQgdG8gdW5uZWNlc3NhcnkgcmVyZW5kZXJzLlxcblNlbGVjdG9ycyB0aGF0IHJldHVybiBhIG5ldyByZWZlcmVuY2UgKHN1Y2ggYXMgYW4gb2JqZWN0IG9yIGFuIGFycmF5KSBzaG91bGQgYmUgbWVtb2l6ZWQ6IGh0dHBzOi8vcmVkdXguanMub3JnL3VzYWdlL2Rlcml2aW5nLWRhdGEtc2VsZWN0b3JzI29wdGltaXppbmctc2VsZWN0b3JzLXdpdGgtbWVtb2l6YXRpb25cIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDI6IHRvQ29tcGFyZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmluYWxJZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPT09IFwiYWx3YXlzXCIgfHwgZmluYWxJZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPT09IFwib25jZVwiICYmIGZpcnN0UnVuLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgKHsgc3RhY2sgfSA9IGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICBcIlNlbGVjdG9yIFwiICsgKHNlbGVjdG9yLm5hbWUgfHwgXCJ1bmtub3duXCIpICsgXCIgcmV0dXJuZWQgdGhlIHJvb3Qgc3RhdGUgd2hlbiBjYWxsZWQuIFRoaXMgY2FuIGxlYWQgdG8gdW5uZWNlc3NhcnkgcmVyZW5kZXJzLlxcblNlbGVjdG9ycyB0aGF0IHJldHVybiB0aGUgZW50aXJlIHN0YXRlIGFyZSBhbG1vc3QgY2VydGFpbmx5IGEgbWlzdGFrZSwgYXMgdGhleSB3aWxsIGNhdXNlIGEgcmVyZW5kZXIgd2hlbmV2ZXIgKmFueXRoaW5nKiBpbiBzdGF0ZSBjaGFuZ2VzLlwiLFxuICAgICAgICAgICAgICAgICAgeyBzdGFjayB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0UnVuLmN1cnJlbnQpXG4gICAgICAgICAgICAgIGZpcnN0UnVuLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICB9W3NlbGVjdG9yLm5hbWVdLFxuICAgICAgW3NlbGVjdG9yLCBzdGFiaWxpdHlDaGVjaywgZGV2TW9kZUNoZWNrcy5zdGFiaWxpdHlDaGVja11cbiAgICApO1xuICAgIGNvbnN0IHNlbGVjdGVkU3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICAgIHN1YnNjcmlwdGlvbi5hZGROZXN0ZWRTdWIsXG4gICAgICBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgIGdldFNlcnZlclN0YXRlIHx8IHN0b3JlLmdldFN0YXRlLFxuICAgICAgd3JhcHBlZFNlbGVjdG9yLFxuICAgICAgZXF1YWxpdHlGblxuICAgICk7XG4gICAgUmVhY3QudXNlRGVidWdWYWx1ZShzZWxlY3RlZFN0YXRlKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRTdGF0ZTtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih1c2VTZWxlY3RvcjIsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHVzZVNlbGVjdG9yMlxuICB9KTtcbiAgcmV0dXJuIHVzZVNlbGVjdG9yMjtcbn1cbnZhciB1c2VTZWxlY3RvciA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTZWxlY3Rvckhvb2soKTtcblxuLy8gc3JjL3V0aWxzL3JlYWN0LWlzLnRzXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIik7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIik7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIik7XG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zZXJ2ZXJfY29udGV4dFwiKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIik7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIik7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIik7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpO1xudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIiAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICBjb25zdCAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRToge1xuICAgICAgICBjb25zdCB0eXBlID0gb2JqZWN0LnR5cGU7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGNvbnN0ICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOiB7XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5cbi8vIHNyYy91dGlscy93YXJuaW5nLnRzXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIHRyeSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxuLy8gc3JjL2Nvbm5lY3QvdmVyaWZ5U3Vic2VsZWN0b3JzLnRzXG5mdW5jdGlvbiB2ZXJpZnkoc2VsZWN0b3IsIG1ldGhvZE5hbWUpIHtcbiAgaWYgKCFzZWxlY3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB2YWx1ZSBmb3IgJHttZXRob2ROYW1lfSBpbiBjb25uZWN0LmApO1xuICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09IFwibWFwU3RhdGVUb1Byb3BzXCIgfHwgbWV0aG9kTmFtZSA9PT0gXCJtYXBEaXNwYXRjaFRvUHJvcHNcIikge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGVjdG9yLCBcImRlcGVuZHNPbk93blByb3BzXCIpKSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBgVGhlIHNlbGVjdG9yIGZvciAke21ldGhvZE5hbWV9IG9mIGNvbm5lY3QgZGlkIG5vdCBzcGVjaWZ5IGEgdmFsdWUgZm9yIGRlcGVuZHNPbk93blByb3BzLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB2ZXJpZnlTdWJzZWxlY3RvcnMobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpIHtcbiAgdmVyaWZ5KG1hcFN0YXRlVG9Qcm9wcywgXCJtYXBTdGF0ZVRvUHJvcHNcIik7XG4gIHZlcmlmeShtYXBEaXNwYXRjaFRvUHJvcHMsIFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpO1xuICB2ZXJpZnkobWVyZ2VQcm9wcywgXCJtZXJnZVByb3BzXCIpO1xufVxuXG4vLyBzcmMvY29ubmVjdC9zZWxlY3RvckZhY3RvcnkudHNcbmZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwYXRjaCwge1xuICBhcmVTdGF0ZXNFcXVhbCxcbiAgYXJlT3duUHJvcHNFcXVhbCxcbiAgYXJlU3RhdGVQcm9wc0VxdWFsXG59KSB7XG4gIGxldCBoYXNSdW5BdExlYXN0T25jZSA9IGZhbHNlO1xuICBsZXQgc3RhdGU7XG4gIGxldCBvd25Qcm9wcztcbiAgbGV0IHN0YXRlUHJvcHM7XG4gIGxldCBkaXNwYXRjaFByb3BzO1xuICBsZXQgbWVyZ2VkUHJvcHM7XG4gIGZ1bmN0aW9uIGhhbmRsZUZpcnN0Q2FsbChmaXJzdFN0YXRlLCBmaXJzdE93blByb3BzKSB7XG4gICAgc3RhdGUgPSBmaXJzdFN0YXRlO1xuICAgIG93blByb3BzID0gZmlyc3RPd25Qcm9wcztcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgaGFzUnVuQXRMZWFzdE9uY2UgPSB0cnVlO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCkge1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBpZiAobWFwRGlzcGF0Y2hUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKVxuICAgICAgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1Byb3BzKCkge1xuICAgIGlmIChtYXBTdGF0ZVRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpXG4gICAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVOZXdTdGF0ZSgpIHtcbiAgICBjb25zdCBuZXh0U3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGNvbnN0IHN0YXRlUHJvcHNDaGFuZ2VkID0gIWFyZVN0YXRlUHJvcHNFcXVhbChuZXh0U3RhdGVQcm9wcywgc3RhdGVQcm9wcyk7XG4gICAgc3RhdGVQcm9wcyA9IG5leHRTdGF0ZVByb3BzO1xuICAgIGlmIChzdGF0ZVByb3BzQ2hhbmdlZClcbiAgICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVN1YnNlcXVlbnRDYWxscyhuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykge1xuICAgIGNvbnN0IHByb3BzQ2hhbmdlZCA9ICFhcmVPd25Qcm9wc0VxdWFsKG5leHRPd25Qcm9wcywgb3duUHJvcHMpO1xuICAgIGNvbnN0IHN0YXRlQ2hhbmdlZCA9ICFhcmVTdGF0ZXNFcXVhbChcbiAgICAgIG5leHRTdGF0ZSxcbiAgICAgIHN0YXRlLFxuICAgICAgbmV4dE93blByb3BzLFxuICAgICAgb3duUHJvcHNcbiAgICApO1xuICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuICAgIG93blByb3BzID0gbmV4dE93blByb3BzO1xuICAgIGlmIChwcm9wc0NoYW5nZWQgJiYgc3RhdGVDaGFuZ2VkKVxuICAgICAgcmV0dXJuIGhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUoKTtcbiAgICBpZiAocHJvcHNDaGFuZ2VkKVxuICAgICAgcmV0dXJuIGhhbmRsZU5ld1Byb3BzKCk7XG4gICAgaWYgKHN0YXRlQ2hhbmdlZClcbiAgICAgIHJldHVybiBoYW5kbGVOZXdTdGF0ZSgpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvcihuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykge1xuICAgIHJldHVybiBoYXNSdW5BdExlYXN0T25jZSA/IGhhbmRsZVN1YnNlcXVlbnRDYWxscyhuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykgOiBoYW5kbGVGaXJzdENhbGwobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpO1xuICB9O1xufVxuZnVuY3Rpb24gZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShkaXNwYXRjaCwge1xuICBpbml0TWFwU3RhdGVUb1Byb3BzLFxuICBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICBpbml0TWVyZ2VQcm9wcyxcbiAgLi4ub3B0aW9uc1xufSkge1xuICBjb25zdCBtYXBTdGF0ZVRvUHJvcHMgPSBpbml0TWFwU3RhdGVUb1Byb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgY29uc3QgbWFwRGlzcGF0Y2hUb1Byb3BzID0gaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIGNvbnN0IG1lcmdlUHJvcHMgPSBpbml0TWVyZ2VQcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2ZXJpZnlTdWJzZWxlY3RvcnMobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpO1xuICB9XG4gIHJldHVybiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gsIG9wdGlvbnMpO1xufVxuXG4vLyBzcmMvdXRpbHMvYmluZEFjdGlvbkNyZWF0b3JzLnRzXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSB7XG4gIGNvbnN0IGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gYWN0aW9uQ3JlYXRvcnMpIHtcbiAgICBjb25zdCBhY3Rpb25DcmVhdG9yID0gYWN0aW9uQ3JlYXRvcnNba2V5XTtcbiAgICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gKC4uLmFyZ3MpID0+IGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IoLi4uYXJncykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn1cblxuLy8gc3JjL3V0aWxzL2lzUGxhaW5PYmplY3QudHNcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iaiA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gIGlmIChwcm90byA9PT0gbnVsbClcbiAgICByZXR1cm4gdHJ1ZTtcbiAgbGV0IGJhc2VQcm90byA9IHByb3RvO1xuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90bykgIT09IG51bGwpIHtcbiAgICBiYXNlUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZVByb3RvKTtcbiAgfVxuICByZXR1cm4gcHJvdG8gPT09IGJhc2VQcm90bztcbn1cblxuLy8gc3JjL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0LnRzXG5mdW5jdGlvbiB2ZXJpZnlQbGFpbk9iamVjdCh2YWx1ZSwgZGlzcGxheU5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHdhcm5pbmcoXG4gICAgICBgJHttZXRob2ROYW1lfSgpIGluICR7ZGlzcGxheU5hbWV9IG11c3QgcmV0dXJuIGEgcGxhaW4gb2JqZWN0LiBJbnN0ZWFkIHJlY2VpdmVkICR7dmFsdWV9LmBcbiAgICApO1xuICB9XG59XG5cbi8vIHNyYy9jb25uZWN0L3dyYXBNYXBUb1Byb3BzLnRzXG5mdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGdldENvbnN0YW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0Q29uc3RhbnRTZWxlY3RvcihkaXNwYXRjaCkge1xuICAgIGNvbnN0IGNvbnN0YW50ID0gZ2V0Q29uc3RhbnQoZGlzcGF0Y2gpO1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50U2VsZWN0b3IoKSB7XG4gICAgICByZXR1cm4gY29uc3RhbnQ7XG4gICAgfVxuICAgIGNvbnN0YW50U2VsZWN0b3IuZGVwZW5kc09uT3duUHJvcHMgPSBmYWxzZTtcbiAgICByZXR1cm4gY29uc3RhbnRTZWxlY3RvcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMgPyBCb29sZWFuKG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIDogbWFwVG9Qcm9wcy5sZW5ndGggIT09IDE7XG59XG5mdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwVG9Qcm9wcywgbWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdFByb3h5U2VsZWN0b3IoZGlzcGF0Y2gsIHsgZGlzcGxheU5hbWUgfSkge1xuICAgIGNvbnN0IHByb3h5ID0gZnVuY3Rpb24gbWFwVG9Qcm9wc1Byb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIHtcbiAgICAgIHJldHVybiBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA/IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykgOiBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCwgdm9pZCAwKTtcbiAgICB9O1xuICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gdHJ1ZTtcbiAgICBwcm94eS5tYXBUb1Byb3BzID0gZnVuY3Rpb24gZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICBwcm94eS5tYXBUb1Byb3BzID0gbWFwVG9Qcm9wcztcbiAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcyk7XG4gICAgICBsZXQgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBwcm94eS5tYXBUb1Byb3BzID0gcHJvcHM7XG4gICAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMocHJvcHMpO1xuICAgICAgICBwcm9wcyA9IHByb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIilcbiAgICAgICAgdmVyaWZ5UGxhaW5PYmplY3QocHJvcHMsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKTtcbiAgICAgIHJldHVybiBwcm9wcztcbiAgICB9O1xuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvaW52YWxpZEFyZ0ZhY3RvcnkudHNcbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KGFyZywgbmFtZSkge1xuICByZXR1cm4gKGRpc3BhdGNoLCBvcHRpb25zKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBhcmd9IGZvciAke25hbWV9IGFyZ3VtZW50IHdoZW4gY29ubmVjdGluZyBjb21wb25lbnQgJHtvcHRpb25zLndyYXBwZWRDb21wb25lbnROYW1lfS5gXG4gICAgKTtcbiAgfTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvbWFwRGlzcGF0Y2hUb1Byb3BzLnRzXG5mdW5jdGlvbiBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gbWFwRGlzcGF0Y2hUb1Byb3BzICYmIHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09IFwib2JqZWN0XCIgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KFxuICAgIChkaXNwYXRjaCkgPT4gKFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgYmluZEFjdGlvbkNyZWF0b3JzKG1hcERpc3BhdGNoVG9Qcm9wcywgZGlzcGF0Y2gpXG4gICAgKVxuICApIDogIW1hcERpc3BhdGNoVG9Qcm9wcyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoKGRpc3BhdGNoKSA9PiAoe1xuICAgIGRpc3BhdGNoXG4gIH0pKSA6IHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09IFwiZnVuY3Rpb25cIiA/IChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd3JhcE1hcFRvUHJvcHNGdW5jKG1hcERpc3BhdGNoVG9Qcm9wcywgXCJtYXBEaXNwYXRjaFRvUHJvcHNcIilcbiAgKSA6IGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcywgXCJtYXBEaXNwYXRjaFRvUHJvcHNcIik7XG59XG5cbi8vIHNyYy9jb25uZWN0L21hcFN0YXRlVG9Qcm9wcy50c1xuZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMpIHtcbiAgcmV0dXJuICFtYXBTdGF0ZVRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KCgpID0+ICh7fSkpIDogdHlwZW9mIG1hcFN0YXRlVG9Qcm9wcyA9PT0gXCJmdW5jdGlvblwiID8gKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwU3RhdGVUb1Byb3BzLCBcIm1hcFN0YXRlVG9Qcm9wc1wiKVxuICApIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBcIm1hcFN0YXRlVG9Qcm9wc1wiKTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvbWVyZ2VQcm9wcy50c1xuZnVuY3Rpb24gZGVmYXVsdE1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgcmV0dXJuIHsgLi4ub3duUHJvcHMsIC4uLnN0YXRlUHJvcHMsIC4uLmRpc3BhdGNoUHJvcHMgfTtcbn1cbmZ1bmN0aW9uIHdyYXBNZXJnZVByb3BzRnVuYyhtZXJnZVByb3BzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0TWVyZ2VQcm9wc1Byb3h5KGRpc3BhdGNoLCB7IGRpc3BsYXlOYW1lLCBhcmVNZXJnZWRQcm9wc0VxdWFsIH0pIHtcbiAgICBsZXQgaGFzUnVuT25jZSA9IGZhbHNlO1xuICAgIGxldCBtZXJnZWRQcm9wcztcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VQcm9wc1Byb3h5KHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSB7XG4gICAgICBjb25zdCBuZXh0TWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICAgIGlmIChoYXNSdW5PbmNlKSB7XG4gICAgICAgIGlmICghYXJlTWVyZ2VkUHJvcHNFcXVhbChuZXh0TWVyZ2VkUHJvcHMsIG1lcmdlZFByb3BzKSlcbiAgICAgICAgICBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1J1bk9uY2UgPSB0cnVlO1xuICAgICAgICBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIilcbiAgICAgICAgICB2ZXJpZnlQbGFpbk9iamVjdChtZXJnZWRQcm9wcywgZGlzcGxheU5hbWUsIFwibWVyZ2VQcm9wc1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VQcm9wc0ZhY3RvcnkobWVyZ2VQcm9wcykge1xuICByZXR1cm4gIW1lcmdlUHJvcHMgPyAoKSA9PiBkZWZhdWx0TWVyZ2VQcm9wcyA6IHR5cGVvZiBtZXJnZVByb3BzID09PSBcImZ1bmN0aW9uXCIgPyB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykgOiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShtZXJnZVByb3BzLCBcIm1lcmdlUHJvcHNcIik7XG59XG5cbi8vIHNyYy91dGlscy9iYXRjaC50c1xuZnVuY3Rpb24gZGVmYXVsdE5vb3BCYXRjaChjYWxsYmFjaykge1xuICBjYWxsYmFjaygpO1xufVxuXG4vLyBzcmMvdXRpbHMvU3Vic2NyaXB0aW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKSB7XG4gIGxldCBmaXJzdCA9IG51bGw7XG4gIGxldCBsYXN0ID0gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBjbGVhcigpIHtcbiAgICAgIGZpcnN0ID0gbnVsbDtcbiAgICAgIGxhc3QgPSBudWxsO1xuICAgIH0sXG4gICAgbm90aWZ5KCkge1xuICAgICAgZGVmYXVsdE5vb3BCYXRjaCgoKSA9PiB7XG4gICAgICAgIGxldCBsaXN0ZW5lciA9IGZpcnN0O1xuICAgICAgICB3aGlsZSAobGlzdGVuZXIpIHtcbiAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjaygpO1xuICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgIGxldCBsaXN0ZW5lciA9IGZpcnN0O1xuICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3RlbmVycztcbiAgICB9LFxuICAgIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgICAgbGV0IGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IGxhc3QgPSB7XG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICBwcmV2OiBsYXN0XG4gICAgICB9O1xuICAgICAgaWYgKGxpc3RlbmVyLnByZXYpIHtcbiAgICAgICAgbGlzdGVuZXIucHJldi5uZXh0ID0gbGlzdGVuZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdCA9IGxpc3RlbmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAoIWlzU3Vic2NyaWJlZCB8fCBmaXJzdCA9PT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICBpZiAobGlzdGVuZXIubmV4dCkge1xuICAgICAgICAgIGxpc3RlbmVyLm5leHQucHJldiA9IGxpc3RlbmVyLnByZXY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdCA9IGxpc3RlbmVyLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyLnByZXYpIHtcbiAgICAgICAgICBsaXN0ZW5lci5wcmV2Lm5leHQgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpcnN0ID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG52YXIgbnVsbExpc3RlbmVycyA9IHtcbiAgbm90aWZ5KCkge1xuICB9LFxuICBnZXQ6ICgpID0+IFtdXG59O1xuZnVuY3Rpb24gY3JlYXRlU3Vic2NyaXB0aW9uKHN0b3JlLCBwYXJlbnRTdWIpIHtcbiAgbGV0IHVuc3Vic2NyaWJlO1xuICBsZXQgbGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgbGV0IHN1YnNjcmlwdGlvbnNBbW91bnQgPSAwO1xuICBsZXQgc2VsZlN1YnNjcmliZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gYWRkTmVzdGVkU3ViKGxpc3RlbmVyKSB7XG4gICAgdHJ5U3Vic2NyaWJlKCk7XG4gICAgY29uc3QgY2xlYW51cExpc3RlbmVyID0gbGlzdGVuZXJzLnN1YnNjcmliZShsaXN0ZW5lcik7XG4gICAgbGV0IHJlbW92ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFyZW1vdmVkKSB7XG4gICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwTGlzdGVuZXIoKTtcbiAgICAgICAgdHJ5VW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeU5lc3RlZFN1YnMoKSB7XG4gICAgbGlzdGVuZXJzLm5vdGlmeSgpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUNoYW5nZVdyYXBwZXIoKSB7XG4gICAgaWYgKHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlKSB7XG4gICAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc1N1YnNjcmliZWQoKSB7XG4gICAgcmV0dXJuIHNlbGZTdWJzY3JpYmVkO1xuICB9XG4gIGZ1bmN0aW9uIHRyeVN1YnNjcmliZSgpIHtcbiAgICBzdWJzY3JpcHRpb25zQW1vdW50Kys7XG4gICAgaWYgKCF1bnN1YnNjcmliZSkge1xuICAgICAgdW5zdWJzY3JpYmUgPSBwYXJlbnRTdWIgPyBwYXJlbnRTdWIuYWRkTmVzdGVkU3ViKGhhbmRsZUNoYW5nZVdyYXBwZXIpIDogc3RvcmUuc3Vic2NyaWJlKGhhbmRsZUNoYW5nZVdyYXBwZXIpO1xuICAgICAgbGlzdGVuZXJzID0gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyeVVuc3Vic2NyaWJlKCkge1xuICAgIHN1YnNjcmlwdGlvbnNBbW91bnQtLTtcbiAgICBpZiAodW5zdWJzY3JpYmUgJiYgc3Vic2NyaXB0aW9uc0Ftb3VudCA9PT0gMCkge1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIHVuc3Vic2NyaWJlID0gdm9pZCAwO1xuICAgICAgbGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgICBsaXN0ZW5lcnMgPSBudWxsTGlzdGVuZXJzO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cnlTdWJzY3JpYmVTZWxmKCkge1xuICAgIGlmICghc2VsZlN1YnNjcmliZWQpIHtcbiAgICAgIHNlbGZTdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgIHRyeVN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZVNlbGYoKSB7XG4gICAgaWYgKHNlbGZTdWJzY3JpYmVkKSB7XG4gICAgICBzZWxmU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgdHJ5VW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3Vic2NyaXB0aW9uID0ge1xuICAgIGFkZE5lc3RlZFN1YixcbiAgICBub3RpZnlOZXN0ZWRTdWJzLFxuICAgIGhhbmRsZUNoYW5nZVdyYXBwZXIsXG4gICAgaXNTdWJzY3JpYmVkLFxuICAgIHRyeVN1YnNjcmliZTogdHJ5U3Vic2NyaWJlU2VsZixcbiAgICB0cnlVbnN1YnNjcmliZTogdHJ5VW5zdWJzY3JpYmVTZWxmLFxuICAgIGdldExpc3RlbmVyczogKCkgPT4gbGlzdGVuZXJzXG4gIH07XG4gIHJldHVybiBzdWJzY3JpcHRpb247XG59XG5cbi8vIHNyYy91dGlscy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LnRzXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIik7XG52YXIgaXNSZWFjdE5hdGl2ZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwiUmVhY3ROYXRpdmVcIjtcbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gY2FuVXNlRE9NIHx8IGlzUmVhY3ROYXRpdmUgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG5cbi8vIHNyYy91dGlscy9zaGFsbG93RXF1YWwudHNcbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gXCJvYmplY3RcIiB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSBcIm9iamVjdFwiIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gc3JjL3V0aWxzL2hvaXN0U3RhdGljcy50c1xudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICBjb250ZXh0VHlwZTogdHJ1ZSxcbiAgY29udGV4dFR5cGVzOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB0cnVlLFxuICBtaXhpbnM6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICBuYW1lOiB0cnVlLFxuICBsZW5ndGg6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZSxcbiAgY2FsbGVyOiB0cnVlLFxuICBjYWxsZWU6IHRydWUsXG4gIGFyZ3VtZW50czogdHJ1ZSxcbiAgYXJpdHk6IHRydWVcbn07XG52YXIgRk9SV0FSRF9SRUZfU1RBVElDUyA9IHtcbiAgJCR0eXBlb2Y6IHRydWUsXG4gIHJlbmRlcjogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlXG59O1xudmFyIE1FTU9fU1RBVElDUyA9IHtcbiAgJCR0eXBlb2Y6IHRydWUsXG4gIGNvbXBhcmU6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBUWVBFX1NUQVRJQ1MgPSB7XG4gIFtGb3J3YXJkUmVmXTogRk9SV0FSRF9SRUZfU1RBVElDUyxcbiAgW01lbW9dOiBNRU1PX1NUQVRJQ1Ncbn07XG5mdW5jdGlvbiBnZXRTdGF0aWNzKGNvbXBvbmVudCkge1xuICBpZiAoaXNNZW1vKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gTUVNT19TVEFUSUNTO1xuICB9XG4gIHJldHVybiBUWVBFX1NUQVRJQ1NbY29tcG9uZW50W1wiJCR0eXBlb2ZcIl1dIHx8IFJFQUNUX1NUQVRJQ1M7XG59XG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQpIHtcbiAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAob2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICBjb25zdCBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuICAgIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFN0YXRpY3MgPSBnZXRTdGF0aWNzKHRhcmdldENvbXBvbmVudCk7XG4gICAgY29uc3Qgc291cmNlU3RhdGljcyA9IGdldFN0YXRpY3Moc291cmNlQ29tcG9uZW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoIUtOT1dOX1NUQVRJQ1Nba2V5XSAmJiAhKHNvdXJjZVN0YXRpY3MgJiYgc291cmNlU3RhdGljc1trZXldKSAmJiAhKHRhcmdldFN0YXRpY3MgJiYgdGFyZ2V0U3RhdGljc1trZXldKSkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9jb25uZWN0LnRzeFxudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gbm90SW5pdGlhbGl6ZWQ7XG52YXIgaW5pdGlhbGl6ZUNvbm5lY3QgPSAoZm4pID0+IHtcbiAgdXNlU3luY0V4dGVybmFsU3RvcmUgPSBmbjtcbn07XG52YXIgTk9fU1VCU0NSSVBUSU9OX0FSUkFZID0gW251bGwsIG51bGxdO1xudmFyIHN0cmluZ2lmeUNvbXBvbmVudCA9IChDb21wKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KENvbXApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nKENvbXApO1xuICB9XG59O1xuZnVuY3Rpb24gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKGVmZmVjdEZ1bmMsIGVmZmVjdEFyZ3MsIGRlcGVuZGVuY2llcykge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IGVmZmVjdEZ1bmMoLi4uZWZmZWN0QXJncyksIGRlcGVuZGVuY2llcyk7XG59XG5mdW5jdGlvbiBjYXB0dXJlV3JhcHBlclByb3BzKGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgd3JhcHBlclByb3BzLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzKSB7XG4gIGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudCA9IHdyYXBwZXJQcm9wcztcbiAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IGZhbHNlO1xuICBpZiAoY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50KSB7XG4gICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gbnVsbDtcbiAgICBub3RpZnlOZXN0ZWRTdWJzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHN1YnNjcmliZVVwZGF0ZXMoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLCBzdG9yZSwgc3Vic2NyaXB0aW9uLCBjaGlsZFByb3BzU2VsZWN0b3IsIGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgaXNNb3VudGVkLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzLCBhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIpIHtcbiAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICBsZXQgZGlkVW5zdWJzY3JpYmUgPSBmYWxzZTtcbiAgbGV0IGxhc3RUaHJvd25FcnJvciA9IG51bGw7XG4gIGNvbnN0IGNoZWNrRm9yVXBkYXRlcyA9ICgpID0+IHtcbiAgICBpZiAoZGlkVW5zdWJzY3JpYmUgfHwgIWlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhdGVzdFN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGxldCBuZXdDaGlsZFByb3BzLCBlcnJvcjtcbiAgICB0cnkge1xuICAgICAgbmV3Q2hpbGRQcm9wcyA9IGNoaWxkUHJvcHNTZWxlY3RvcihcbiAgICAgICAgbGF0ZXN0U3RvcmVTdGF0ZSxcbiAgICAgICAgbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yID0gZTtcbiAgICAgIGxhc3RUaHJvd25FcnJvciA9IGU7XG4gICAgfVxuICAgIGlmICghZXJyb3IpIHtcbiAgICAgIGxhc3RUaHJvd25FcnJvciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChuZXdDaGlsZFByb3BzID09PSBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50KSB7XG4gICAgICBpZiAoIXJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQpIHtcbiAgICAgICAgbm90aWZ5TmVzdGVkU3VicygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50ID0gbmV3Q2hpbGRQcm9wcztcbiAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IG5ld0NoaWxkUHJvcHM7XG4gICAgICByZW5kZXJJc1NjaGVkdWxlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGFkZGl0aW9uYWxTdWJzY3JpYmVMaXN0ZW5lcigpO1xuICAgIH1cbiAgfTtcbiAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBjaGVja0ZvclVwZGF0ZXM7XG4gIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcbiAgY2hlY2tGb3JVcGRhdGVzKCk7XG4gIGNvbnN0IHVuc3Vic2NyaWJlV3JhcHBlciA9ICgpID0+IHtcbiAgICBkaWRVbnN1YnNjcmliZSA9IHRydWU7XG4gICAgc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBudWxsO1xuICAgIGlmIChsYXN0VGhyb3duRXJyb3IpIHtcbiAgICAgIHRocm93IGxhc3RUaHJvd25FcnJvcjtcbiAgICB9XG4gIH07XG4gIHJldHVybiB1bnN1YnNjcmliZVdyYXBwZXI7XG59XG5mdW5jdGlvbiBzdHJpY3RFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24gPSBmYWxzZTtcbmZ1bmN0aW9uIGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIHtcbiAgLy8gVGhlIGBwdXJlYCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZCwgc28gVFMgZG9lc24ndCBsaWtlIHVzIGRlc3RydWN0dXJpbmcgdGhpcyB0byBjaGVjayBpdHMgZXhpc3RlbmNlLlxuICAvLyBAdHMtaWdub3JlXG4gIHB1cmUsXG4gIGFyZVN0YXRlc0VxdWFsID0gc3RyaWN0RXF1YWwsXG4gIGFyZU93blByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbCA9IHNoYWxsb3dFcXVhbCxcbiAgYXJlTWVyZ2VkUHJvcHNFcXVhbCA9IHNoYWxsb3dFcXVhbCxcbiAgLy8gdXNlIFJlYWN0J3MgZm9yd2FyZFJlZiB0byBleHBvc2UgYSByZWYgb2YgdGhlIHdyYXBwZWQgY29tcG9uZW50XG4gIGZvcndhcmRSZWYgPSBmYWxzZSxcbiAgLy8gdGhlIGNvbnRleHQgY29uc3VtZXIgdG8gdXNlXG4gIGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dFxufSA9IHt9KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAocHVyZSAhPT0gdm9pZCAwICYmICFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgICdUaGUgYHB1cmVgIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkLiBgY29ubmVjdGAgaXMgbm93IGFsd2F5cyBhIFwicHVyZS9tZW1vaXplZFwiIGNvbXBvbmVudCdcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGNvbnN0IENvbnRleHQgPSBjb250ZXh0O1xuICBjb25zdCBpbml0TWFwU3RhdGVUb1Byb3BzID0gbWFwU3RhdGVUb1Byb3BzRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMpO1xuICBjb25zdCBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yeShtYXBEaXNwYXRjaFRvUHJvcHMpO1xuICBjb25zdCBpbml0TWVyZ2VQcm9wcyA9IG1lcmdlUHJvcHNGYWN0b3J5KG1lcmdlUHJvcHMpO1xuICBjb25zdCBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMgPSBCb29sZWFuKG1hcFN0YXRlVG9Qcm9wcyk7XG4gIGNvbnN0IHdyYXBXaXRoQ29ubmVjdCA9IChXcmFwcGVkQ29tcG9uZW50KSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc3QgaXNWYWxpZCA9IC8qIEBfX1BVUkVfXyAqLyBpc1ZhbGlkRWxlbWVudFR5cGUoV3JhcHBlZENvbXBvbmVudCk7XG4gICAgICBpZiAoIWlzVmFsaWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgWW91IG11c3QgcGFzcyBhIGNvbXBvbmVudCB0byB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgY29ubmVjdC4gSW5zdGVhZCByZWNlaXZlZCAke3N0cmluZ2lmeUNvbXBvbmVudChcbiAgICAgICAgICAgIFdyYXBwZWRDb21wb25lbnRcbiAgICAgICAgICApfWBcbiAgICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgd3JhcHBlZENvbXBvbmVudE5hbWUgPSBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCBcIkNvbXBvbmVudFwiO1xuICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gYENvbm5lY3QoJHt3cmFwcGVkQ29tcG9uZW50TmFtZX0pYDtcbiAgICBjb25zdCBzZWxlY3RvckZhY3RvcnlPcHRpb25zID0ge1xuICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLFxuICAgICAgZGlzcGxheU5hbWUsXG4gICAgICB3cmFwcGVkQ29tcG9uZW50TmFtZSxcbiAgICAgIFdyYXBwZWRDb21wb25lbnQsXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpbml0TWFwU3RhdGVUb1Byb3BzLFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgICAgIGluaXRNZXJnZVByb3BzLFxuICAgICAgYXJlU3RhdGVzRXF1YWwsXG4gICAgICBhcmVTdGF0ZVByb3BzRXF1YWwsXG4gICAgICBhcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgYXJlTWVyZ2VkUHJvcHNFcXVhbFxuICAgIH07XG4gICAgZnVuY3Rpb24gQ29ubmVjdEZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICBjb25zdCBbcHJvcHNDb250ZXh0LCByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmLCB3cmFwcGVyUHJvcHNdID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVhY3RSZWR1eEZvcndhcmRlZFJlZjogcmVhY3RSZWR1eEZvcndhcmRlZFJlZjIsIC4uLndyYXBwZXJQcm9wczIgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gW3Byb3BzLmNvbnRleHQsIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYyLCB3cmFwcGVyUHJvcHMyXTtcbiAgICAgIH0sIFtwcm9wc10pO1xuICAgICAgY29uc3QgQ29udGV4dFRvVXNlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGxldCBSZXN1bHRDb250ZXh0ID0gQ29udGV4dDtcbiAgICAgICAgaWYgKHByb3BzQ29udGV4dD8uQ29uc3VtZXIpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gLyogQF9fUFVSRV9fICovIGlzQ29udGV4dENvbnN1bWVyKFxuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KHByb3BzQ29udGV4dC5Db25zdW1lciwgbnVsbClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiWW91IG11c3QgcGFzcyBhIHZhbGlkIFJlYWN0IGNvbnRleHQgY29uc3VtZXIgYXMgYHByb3BzLmNvbnRleHRgXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlc3VsdENvbnRleHQgPSBwcm9wc0NvbnRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZXN1bHRDb250ZXh0O1xuICAgICAgfSwgW3Byb3BzQ29udGV4dCwgQ29udGV4dF0pO1xuICAgICAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlQ29udGV4dChDb250ZXh0VG9Vc2UpO1xuICAgICAgY29uc3QgZGlkU3RvcmVDb21lRnJvbVByb3BzID0gQm9vbGVhbihwcm9wcy5zdG9yZSkgJiYgQm9vbGVhbihwcm9wcy5zdG9yZS5nZXRTdGF0ZSkgJiYgQm9vbGVhbihwcm9wcy5zdG9yZS5kaXNwYXRjaCk7XG4gICAgICBjb25zdCBkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCA9IEJvb2xlYW4oY29udGV4dFZhbHVlKSAmJiBCb29sZWFuKGNvbnRleHRWYWx1ZS5zdG9yZSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFkaWRTdG9yZUNvbWVGcm9tUHJvcHMgJiYgIWRpZFN0b3JlQ29tZUZyb21Db250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ291bGQgbm90IGZpbmQgXCJzdG9yZVwiIGluIHRoZSBjb250ZXh0IG9mIFwiJHtkaXNwbGF5TmFtZX1cIi4gRWl0aGVyIHdyYXAgdGhlIHJvb3QgY29tcG9uZW50IGluIGEgPFByb3ZpZGVyPiwgb3IgcGFzcyBhIGN1c3RvbSBSZWFjdCBjb250ZXh0IHByb3ZpZGVyIHRvIDxQcm92aWRlcj4gYW5kIHRoZSBjb3JyZXNwb25kaW5nIFJlYWN0IGNvbnRleHQgY29uc3VtZXIgdG8gJHtkaXNwbGF5TmFtZX0gaW4gY29ubmVjdCBvcHRpb25zLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0b3JlID0gZGlkU3RvcmVDb21lRnJvbVByb3BzID8gcHJvcHMuc3RvcmUgOiBjb250ZXh0VmFsdWUuc3RvcmU7XG4gICAgICBjb25zdCBnZXRTZXJ2ZXJTdGF0ZSA9IGRpZFN0b3JlQ29tZUZyb21Db250ZXh0ID8gY29udGV4dFZhbHVlLmdldFNlcnZlclN0YXRlIDogc3RvcmUuZ2V0U3RhdGU7XG4gICAgICBjb25zdCBjaGlsZFByb3BzU2VsZWN0b3IgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGZpbmFsUHJvcHNTZWxlY3RvckZhY3Rvcnkoc3RvcmUuZGlzcGF0Y2gsIHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMpO1xuICAgICAgfSwgW3N0b3JlXSk7XG4gICAgICBjb25zdCBbc3Vic2NyaXB0aW9uLCBub3RpZnlOZXN0ZWRTdWJzXSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcylcbiAgICAgICAgICByZXR1cm4gTk9fU1VCU0NSSVBUSU9OX0FSUkFZO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24yID0gY3JlYXRlU3Vic2NyaXB0aW9uKFxuICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgIGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA/IHZvaWQgMCA6IGNvbnRleHRWYWx1ZS5zdWJzY3JpcHRpb25cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgbm90aWZ5TmVzdGVkU3ViczIgPSBzdWJzY3JpcHRpb24yLm5vdGlmeU5lc3RlZFN1YnMuYmluZChzdWJzY3JpcHRpb24yKTtcbiAgICAgICAgcmV0dXJuIFtzdWJzY3JpcHRpb24yLCBub3RpZnlOZXN0ZWRTdWJzMl07XG4gICAgICB9LCBbc3RvcmUsIGRpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlXSk7XG4gICAgICBjb25zdCBvdmVycmlkZGVuQ29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChkaWRTdG9yZUNvbWVGcm9tUHJvcHMpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uY29udGV4dFZhbHVlLFxuICAgICAgICAgIHN1YnNjcmlwdGlvblxuICAgICAgICB9O1xuICAgICAgfSwgW2RpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlLCBzdWJzY3JpcHRpb25dKTtcbiAgICAgIGNvbnN0IGxhc3RDaGlsZFByb3BzID0gUmVhY3QudXNlUmVmKHZvaWQgMCk7XG4gICAgICBjb25zdCBsYXN0V3JhcHBlclByb3BzID0gUmVhY3QudXNlUmVmKHdyYXBwZXJQcm9wcyk7XG4gICAgICBjb25zdCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlID0gUmVhY3QudXNlUmVmKHZvaWQgMCk7XG4gICAgICBjb25zdCByZW5kZXJJc1NjaGVkdWxlZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgICBjb25zdCBpc01vdW50ZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgICAgY29uc3QgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciA9IFJlYWN0LnVzZVJlZihcbiAgICAgICAgdm9pZCAwXG4gICAgICApO1xuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgfSwgW10pO1xuICAgICAgY29uc3QgYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgJiYgd3JhcHBlclByb3BzID09PSBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzU2VsZWN0b3Ioc3RvcmUuZ2V0U3RhdGUoKSwgd3JhcHBlclByb3BzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgfSwgW3N0b3JlLCB3cmFwcGVyUHJvcHNdKTtcbiAgICAgIGNvbnN0IHN1YnNjcmliZUZvclJlYWN0ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZSA9IChyZWFjdExpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlVXBkYXRlcyhcbiAgICAgICAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY2hpbGRQcm9wc1NlbGVjdG9yLFxuICAgICAgICAgICAgbGFzdFdyYXBwZXJQcm9wcyxcbiAgICAgICAgICAgIGxhc3RDaGlsZFByb3BzLFxuICAgICAgICAgICAgcmVuZGVySXNTY2hlZHVsZWQsXG4gICAgICAgICAgICBpc01vdW50ZWQsXG4gICAgICAgICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLFxuICAgICAgICAgICAgbm90aWZ5TmVzdGVkU3VicyxcbiAgICAgICAgICAgIHJlYWN0TGlzdGVuZXJcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlO1xuICAgICAgfSwgW3N1YnNjcmlwdGlvbl0pO1xuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKGNhcHR1cmVXcmFwcGVyUHJvcHMsIFtcbiAgICAgICAgbGFzdFdyYXBwZXJQcm9wcyxcbiAgICAgICAgbGFzdENoaWxkUHJvcHMsXG4gICAgICAgIHJlbmRlcklzU2NoZWR1bGVkLFxuICAgICAgICB3cmFwcGVyUHJvcHMsXG4gICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsXG4gICAgICAgIG5vdGlmeU5lc3RlZFN1YnNcbiAgICAgIF0pO1xuICAgICAgbGV0IGFjdHVhbENoaWxkUHJvcHM7XG4gICAgICB0cnkge1xuICAgICAgICBhY3R1YWxDaGlsZFByb3BzID0gdXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgLy8gVE9ETyBXZSdyZSBwYXNzaW5nIHRocm91Z2ggYSBiaWcgd3JhcHBlciB0aGF0IGRvZXMgYSBidW5jaCBvZiBleHRyYSBzaWRlIGVmZmVjdHMgYmVzaWRlcyBzdWJzY3JpYmluZ1xuICAgICAgICAgIHN1YnNjcmliZUZvclJlYWN0LFxuICAgICAgICAgIC8vIFRPRE8gVGhpcyBpcyBpbmNyZWRpYmx5IGhhY2t5LiBXZSd2ZSBhbHJlYWR5IHByb2Nlc3NlZCB0aGUgc3RvcmUgdXBkYXRlIGFuZCBjYWxjdWxhdGVkIG5ldyBjaGlsZCBwcm9wcyxcbiAgICAgICAgICAvLyBUT0RPIGFuZCB3ZSdyZSBqdXN0IHBhc3NpbmcgdGhhdCB0aHJvdWdoIHNvIGl0IHRyaWdnZXJzIGEgcmUtcmVuZGVyIGZvciB1cyByYXRoZXIgdGhhbiByZWx5aW5nIG9uIGB1U0VTYC5cbiAgICAgICAgICBhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3IsXG4gICAgICAgICAgZ2V0U2VydmVyU3RhdGUgPyAoKSA9PiBjaGlsZFByb3BzU2VsZWN0b3IoZ2V0U2VydmVyU3RhdGUoKSwgd3JhcHBlclByb3BzKSA6IGFjdHVhbENoaWxkUHJvcHNTZWxlY3RvclxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQpIHtcbiAgICAgICAgICA7XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgKz0gYFxuVGhlIGVycm9yIG1heSBiZSBjb3JyZWxhdGVkIHdpdGggdGhpcyBwcmV2aW91cyBlcnJvcjpcbiR7bGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50LnN0YWNrfVxuXG5gO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgbGFzdENoaWxkUHJvcHMuY3VycmVudCA9IGFjdHVhbENoaWxkUHJvcHM7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIFdyYXBwZWRDb21wb25lbnQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLmFjdHVhbENoaWxkUHJvcHMsXG4gICAgICAgICAgICAgIHJlZjogcmVhY3RSZWR1eEZvcndhcmRlZFJlZlxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0sIFtyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmLCBXcmFwcGVkQ29tcG9uZW50LCBhY3R1YWxDaGlsZFByb3BzXSk7XG4gICAgICBjb25zdCByZW5kZXJlZENoaWxkID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHtcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dFRvVXNlLlByb3ZpZGVyLCB7IHZhbHVlOiBvdmVycmlkZGVuQ29udGV4dFZhbHVlIH0sIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudDtcbiAgICAgIH0sIFtDb250ZXh0VG9Vc2UsIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCwgb3ZlcnJpZGRlbkNvbnRleHRWYWx1ZV0pO1xuICAgICAgcmV0dXJuIHJlbmRlcmVkQ2hpbGQ7XG4gICAgfVxuICAgIGNvbnN0IF9Db25uZWN0ID0gUmVhY3QubWVtbyhDb25uZWN0RnVuY3Rpb24pO1xuICAgIGNvbnN0IENvbm5lY3QgPSBfQ29ubmVjdDtcbiAgICBDb25uZWN0LldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgIENvbm5lY3QuZGlzcGxheU5hbWUgPSBDb25uZWN0RnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICBpZiAoZm9yd2FyZFJlZikge1xuICAgICAgY29uc3QgX2ZvcndhcmRlZCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmRDb25uZWN0UmVmKHByb3BzLCByZWYpIHtcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29ubmVjdCwgeyAuLi5wcm9wcywgcmVhY3RSZWR1eEZvcndhcmRlZFJlZjogcmVmIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgY29uc3QgZm9yd2FyZGVkID0gX2ZvcndhcmRlZDtcbiAgICAgIGZvcndhcmRlZC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgICAgZm9yd2FyZGVkLldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBob2lzdE5vblJlYWN0U3RhdGljcyhmb3J3YXJkZWQsIFdyYXBwZWRDb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKENvbm5lY3QsIFdyYXBwZWRDb21wb25lbnQpO1xuICB9O1xuICByZXR1cm4gd3JhcFdpdGhDb25uZWN0O1xufVxudmFyIGNvbm5lY3RfZGVmYXVsdCA9IGNvbm5lY3Q7XG5cbi8vIHNyYy9jb21wb25lbnRzL1Byb3ZpZGVyLnRzeFxuZnVuY3Rpb24gUHJvdmlkZXIoe1xuICBzdG9yZSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHNlcnZlclN0YXRlLFxuICBzdGFiaWxpdHlDaGVjayA9IFwib25jZVwiLFxuICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPSBcIm9uY2VcIlxufSkge1xuICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBjcmVhdGVTdWJzY3JpcHRpb24oc3RvcmUpO1xuICAgIHJldHVybiB7XG4gICAgICBzdG9yZSxcbiAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgIGdldFNlcnZlclN0YXRlOiBzZXJ2ZXJTdGF0ZSA/ICgpID0+IHNlcnZlclN0YXRlIDogdm9pZCAwLFxuICAgICAgc3RhYmlsaXR5Q2hlY2ssXG4gICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2tcbiAgICB9O1xuICB9LCBbc3RvcmUsIHNlcnZlclN0YXRlLCBzdGFiaWxpdHlDaGVjaywgaWRlbnRpdHlGdW5jdGlvbkNoZWNrXSk7XG4gIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHN0b3JlLmdldFN0YXRlKCksIFtzdG9yZV0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7IHN1YnNjcmlwdGlvbiB9ID0gY29udGV4dFZhbHVlO1xuICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gc3Vic2NyaXB0aW9uLm5vdGlmeU5lc3RlZFN1YnM7XG4gICAgc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpO1xuICAgIGlmIChwcmV2aW91c1N0YXRlICE9PSBzdG9yZS5nZXRTdGF0ZSgpKSB7XG4gICAgICBzdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3VicygpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IHZvaWQgMDtcbiAgICB9O1xuICB9LCBbY29udGV4dFZhbHVlLCBwcmV2aW91c1N0YXRlXSk7XG4gIGNvbnN0IENvbnRleHQgPSBjb250ZXh0IHx8IFJlYWN0UmVkdXhDb250ZXh0O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dFZhbHVlIH0sIGNoaWxkcmVuKTtcbn1cbnZhciBQcm92aWRlcl9kZWZhdWx0ID0gUHJvdmlkZXI7XG5cbi8vIHNyYy9ob29rcy91c2VTdG9yZS50c1xuZnVuY3Rpb24gY3JlYXRlU3RvcmVIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICBjb25zdCB1c2VSZWR1eENvbnRleHQyID0gY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VSZWR1eENvbnRleHQgOiAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soY29udGV4dClcbiAgKTtcbiAgY29uc3QgdXNlU3RvcmUyID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgc3RvcmUgfSA9IHVzZVJlZHV4Q29udGV4dDIoKTtcbiAgICByZXR1cm4gc3RvcmU7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odXNlU3RvcmUyLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiB1c2VTdG9yZTJcbiAgfSk7XG4gIHJldHVybiB1c2VTdG9yZTI7XG59XG52YXIgdXNlU3RvcmUgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU3RvcmVIb29rKCk7XG5cbi8vIHNyYy9ob29rcy91c2VEaXNwYXRjaC50c1xuZnVuY3Rpb24gY3JlYXRlRGlzcGF0Y2hIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICBjb25zdCB1c2VTdG9yZTIgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZVN0b3JlIDogY3JlYXRlU3RvcmVIb29rKGNvbnRleHQpO1xuICBjb25zdCB1c2VEaXNwYXRjaDIgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZTIoKTtcbiAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2g7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odXNlRGlzcGF0Y2gyLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiB1c2VEaXNwYXRjaDJcbiAgfSk7XG4gIHJldHVybiB1c2VEaXNwYXRjaDI7XG59XG52YXIgdXNlRGlzcGF0Y2ggPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGlzcGF0Y2hIb29rKCk7XG5cbi8vIHNyYy9leHBvcnRzLnRzXG52YXIgYmF0Y2ggPSBkZWZhdWx0Tm9vcEJhdGNoO1xuXG4vLyBzcmMvaW5kZXgudHNcbmluaXRpYWxpemVVc2VTZWxlY3Rvcih1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIpO1xuaW5pdGlhbGl6ZUNvbm5lY3QoUmVhY3QyLnVzZVN5bmNFeHRlcm5hbFN0b3JlKTtcbmV4cG9ydCB7XG4gIFByb3ZpZGVyX2RlZmF1bHQgYXMgUHJvdmlkZXIsXG4gIFJlYWN0UmVkdXhDb250ZXh0LFxuICBiYXRjaCxcbiAgY29ubmVjdF9kZWZhdWx0IGFzIGNvbm5lY3QsXG4gIGNyZWF0ZURpc3BhdGNoSG9vayxcbiAgY3JlYXRlU2VsZWN0b3JIb29rLFxuICBjcmVhdGVTdG9yZUhvb2ssXG4gIHNoYWxsb3dFcXVhbCxcbiAgdXNlRGlzcGF0Y2gsXG4gIHVzZVNlbGVjdG9yLFxuICB1c2VTdG9yZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXJlZHV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiUmVhY3QyIiwidXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIiLCJSZWFjdE9yaWdpbmFsIiwiUmVhY3QiLCJDb250ZXh0S2V5IiwiU3ltYm9sIiwiZm9yIiwiZ1QiLCJnbG9iYWxUaGlzIiwiZ2V0Q29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJjb250ZXh0TWFwIiwiTWFwIiwicmVhbENvbnRleHQiLCJnZXQiLCJkaXNwbGF5TmFtZSIsInNldCIsIlJlYWN0UmVkdXhDb250ZXh0Iiwibm90SW5pdGlhbGl6ZWQiLCJFcnJvciIsImNyZWF0ZVJlZHV4Q29udGV4dEhvb2siLCJjb250ZXh0IiwidXNlUmVkdXhDb250ZXh0MiIsImNvbnRleHRWYWx1ZSIsInVzZUNvbnRleHQiLCJ1c2VSZWR1eENvbnRleHQiLCJpbml0aWFsaXplVXNlU2VsZWN0b3IiLCJmbiIsInJlZkVxdWFsaXR5IiwiYSIsImIiLCJjcmVhdGVTZWxlY3Rvckhvb2siLCJ1c2VTZWxlY3RvcjIiLCJzZWxlY3RvciIsImVxdWFsaXR5Rm5Pck9wdGlvbnMiLCJlcXVhbGl0eUZuIiwiZGV2TW9kZUNoZWNrcyIsInN0b3JlIiwic3Vic2NyaXB0aW9uIiwiZ2V0U2VydmVyU3RhdGUiLCJzdGFiaWxpdHlDaGVjayIsImlkZW50aXR5RnVuY3Rpb25DaGVjayIsImZpcnN0UnVuIiwidXNlUmVmIiwid3JhcHBlZFNlbGVjdG9yIiwidXNlQ2FsbGJhY2siLCJuYW1lIiwic3RhdGUiLCJzZWxlY3RlZCIsImZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrIiwiZmluYWxTdGFiaWxpdHlDaGVjayIsImN1cnJlbnQiLCJ0b0NvbXBhcmUiLCJzdGFjayIsImUiLCJjb25zb2xlIiwid2FybiIsInNlbGVjdGVkMiIsInNlbGVjdGVkU3RhdGUiLCJhZGROZXN0ZWRTdWIiLCJnZXRTdGF0ZSIsInVzZURlYnVnVmFsdWUiLCJPYmplY3QiLCJhc3NpZ24iLCJ3aXRoVHlwZXMiLCJ1c2VTZWxlY3RvciIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSIsIkZvcndhcmRSZWYiLCJNZW1vIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwidHlwZSIsIiQkdHlwZW9mIiwiZ2V0TW9kdWxlSWQiLCJ0eXBlT2YiLCJvYmplY3QiLCIkJHR5cGVvZlR5cGUiLCJpc0NvbnRleHRDb25zdW1lciIsImlzTWVtbyIsIndhcm5pbmciLCJtZXNzYWdlIiwiZXJyb3IiLCJ2ZXJpZnkiLCJtZXRob2ROYW1lIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmVyaWZ5U3Vic2VsZWN0b3JzIiwibWFwU3RhdGVUb1Byb3BzIiwibWFwRGlzcGF0Y2hUb1Byb3BzIiwibWVyZ2VQcm9wcyIsInB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5IiwiZGlzcGF0Y2giLCJhcmVTdGF0ZXNFcXVhbCIsImFyZU93blByb3BzRXF1YWwiLCJhcmVTdGF0ZVByb3BzRXF1YWwiLCJoYXNSdW5BdExlYXN0T25jZSIsIm93blByb3BzIiwic3RhdGVQcm9wcyIsImRpc3BhdGNoUHJvcHMiLCJtZXJnZWRQcm9wcyIsImhhbmRsZUZpcnN0Q2FsbCIsImZpcnN0U3RhdGUiLCJmaXJzdE93blByb3BzIiwiaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSIsImRlcGVuZHNPbk93blByb3BzIiwiaGFuZGxlTmV3UHJvcHMiLCJoYW5kbGVOZXdTdGF0ZSIsIm5leHRTdGF0ZVByb3BzIiwic3RhdGVQcm9wc0NoYW5nZWQiLCJoYW5kbGVTdWJzZXF1ZW50Q2FsbHMiLCJuZXh0U3RhdGUiLCJuZXh0T3duUHJvcHMiLCJwcm9wc0NoYW5nZWQiLCJzdGF0ZUNoYW5nZWQiLCJwdXJlRmluYWxQcm9wc1NlbGVjdG9yIiwiZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeSIsImluaXRNYXBTdGF0ZVRvUHJvcHMiLCJpbml0TWFwRGlzcGF0Y2hUb1Byb3BzIiwiaW5pdE1lcmdlUHJvcHMiLCJvcHRpb25zIiwiYmluZEFjdGlvbkNyZWF0b3JzIiwiYWN0aW9uQ3JlYXRvcnMiLCJib3VuZEFjdGlvbkNyZWF0b3JzIiwia2V5IiwiYWN0aW9uQ3JlYXRvciIsImFyZ3MiLCJpc1BsYWluT2JqZWN0Iiwib2JqIiwicHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsImJhc2VQcm90byIsInZlcmlmeVBsYWluT2JqZWN0IiwidmFsdWUiLCJ3cmFwTWFwVG9Qcm9wc0NvbnN0YW50IiwiZ2V0Q29uc3RhbnQiLCJpbml0Q29uc3RhbnRTZWxlY3RvciIsImNvbnN0YW50IiwiY29uc3RhbnRTZWxlY3RvciIsImdldERlcGVuZHNPbk93blByb3BzIiwibWFwVG9Qcm9wcyIsIkJvb2xlYW4iLCJsZW5ndGgiLCJ3cmFwTWFwVG9Qcm9wc0Z1bmMiLCJpbml0UHJveHlTZWxlY3RvciIsInByb3h5IiwibWFwVG9Qcm9wc1Byb3h5Iiwic3RhdGVPckRpc3BhdGNoIiwiZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeSIsInByb3BzIiwiY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkiLCJhcmciLCJ3cmFwcGVkQ29tcG9uZW50TmFtZSIsIm1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkiLCJtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5IiwiZGVmYXVsdE1lcmdlUHJvcHMiLCJ3cmFwTWVyZ2VQcm9wc0Z1bmMiLCJpbml0TWVyZ2VQcm9wc1Byb3h5IiwiYXJlTWVyZ2VkUHJvcHNFcXVhbCIsImhhc1J1bk9uY2UiLCJtZXJnZVByb3BzUHJveHkiLCJuZXh0TWVyZ2VkUHJvcHMiLCJtZXJnZVByb3BzRmFjdG9yeSIsImRlZmF1bHROb29wQmF0Y2giLCJjYWxsYmFjayIsImNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbiIsImZpcnN0IiwibGFzdCIsImNsZWFyIiwibm90aWZ5IiwibGlzdGVuZXIiLCJuZXh0IiwibGlzdGVuZXJzIiwicHVzaCIsInN1YnNjcmliZSIsImlzU3Vic2NyaWJlZCIsInByZXYiLCJ1bnN1YnNjcmliZSIsIm51bGxMaXN0ZW5lcnMiLCJjcmVhdGVTdWJzY3JpcHRpb24iLCJwYXJlbnRTdWIiLCJzdWJzY3JpcHRpb25zQW1vdW50Iiwic2VsZlN1YnNjcmliZWQiLCJ0cnlTdWJzY3JpYmUiLCJjbGVhbnVwTGlzdGVuZXIiLCJyZW1vdmVkIiwidHJ5VW5zdWJzY3JpYmUiLCJub3RpZnlOZXN0ZWRTdWJzIiwiaGFuZGxlQ2hhbmdlV3JhcHBlciIsIm9uU3RhdGVDaGFuZ2UiLCJ0cnlTdWJzY3JpYmVTZWxmIiwidHJ5VW5zdWJzY3JpYmVTZWxmIiwiZ2V0TGlzdGVuZXJzIiwiY2FuVXNlRE9NIiwid2luZG93IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaXNSZWFjdE5hdGl2ZSIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwiaXMiLCJ4IiwieSIsInNoYWxsb3dFcXVhbCIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJrZXlzIiwia2V5c0IiLCJpIiwiUkVBQ1RfU1RBVElDUyIsImNoaWxkQ29udGV4dFR5cGVzIiwiY29udGV4dFR5cGUiLCJjb250ZXh0VHlwZXMiLCJkZWZhdWx0UHJvcHMiLCJnZXREZWZhdWx0UHJvcHMiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJtaXhpbnMiLCJwcm9wVHlwZXMiLCJLTk9XTl9TVEFUSUNTIiwiY2FsbGVyIiwiY2FsbGVlIiwiYXJndW1lbnRzIiwiYXJpdHkiLCJGT1JXQVJEX1JFRl9TVEFUSUNTIiwicmVuZGVyIiwiTUVNT19TVEFUSUNTIiwiY29tcGFyZSIsIlRZUEVfU1RBVElDUyIsImdldFN0YXRpY3MiLCJjb21wb25lbnQiLCJkZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJvYmplY3RQcm90b3R5cGUiLCJob2lzdE5vblJlYWN0U3RhdGljcyIsInRhcmdldENvbXBvbmVudCIsInNvdXJjZUNvbXBvbmVudCIsImluaGVyaXRlZENvbXBvbmVudCIsImNvbmNhdCIsInRhcmdldFN0YXRpY3MiLCJzb3VyY2VTdGF0aWNzIiwiZGVzY3JpcHRvciIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwiaW5pdGlhbGl6ZUNvbm5lY3QiLCJOT19TVUJTQ1JJUFRJT05fQVJSQVkiLCJzdHJpbmdpZnlDb21wb25lbnQiLCJDb21wIiwiSlNPTiIsInN0cmluZ2lmeSIsImVyciIsIlN0cmluZyIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RXaXRoQXJncyIsImVmZmVjdEZ1bmMiLCJlZmZlY3RBcmdzIiwiZGVwZW5kZW5jaWVzIiwiY2FwdHVyZVdyYXBwZXJQcm9wcyIsImxhc3RXcmFwcGVyUHJvcHMiLCJsYXN0Q2hpbGRQcm9wcyIsInJlbmRlcklzU2NoZWR1bGVkIiwid3JhcHBlclByb3BzIiwiY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSIsInN1YnNjcmliZVVwZGF0ZXMiLCJzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMiLCJjaGlsZFByb3BzU2VsZWN0b3IiLCJpc01vdW50ZWQiLCJhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIiLCJkaWRVbnN1YnNjcmliZSIsImxhc3RUaHJvd25FcnJvciIsImNoZWNrRm9yVXBkYXRlcyIsImxhdGVzdFN0b3JlU3RhdGUiLCJuZXdDaGlsZFByb3BzIiwidW5zdWJzY3JpYmVXcmFwcGVyIiwic3RyaWN0RXF1YWwiLCJoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uIiwiY29ubmVjdCIsInB1cmUiLCJmb3J3YXJkUmVmIiwiQ29udGV4dCIsIndyYXBXaXRoQ29ubmVjdCIsIldyYXBwZWRDb21wb25lbnQiLCJpc1ZhbGlkIiwic2VsZWN0b3JGYWN0b3J5T3B0aW9ucyIsIkNvbm5lY3RGdW5jdGlvbiIsInByb3BzQ29udGV4dCIsInJlYWN0UmVkdXhGb3J3YXJkZWRSZWYiLCJ1c2VNZW1vIiwicmVhY3RSZWR1eEZvcndhcmRlZFJlZjIiLCJ3cmFwcGVyUHJvcHMyIiwiQ29udGV4dFRvVXNlIiwiUmVzdWx0Q29udGV4dCIsIkNvbnN1bWVyIiwiZGlkU3RvcmVDb21lRnJvbVByb3BzIiwiZGlkU3RvcmVDb21lRnJvbUNvbnRleHQiLCJzdWJzY3JpcHRpb24yIiwibm90aWZ5TmVzdGVkU3ViczIiLCJiaW5kIiwib3ZlcnJpZGRlbkNvbnRleHRWYWx1ZSIsImxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IiLCJhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3IiLCJzdWJzY3JpYmVGb3JSZWFjdCIsInJlYWN0TGlzdGVuZXIiLCJhY3R1YWxDaGlsZFByb3BzIiwicmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50IiwicmVmIiwicmVuZGVyZWRDaGlsZCIsIlByb3ZpZGVyIiwiX0Nvbm5lY3QiLCJtZW1vIiwiQ29ubmVjdCIsIl9mb3J3YXJkZWQiLCJmb3J3YXJkQ29ubmVjdFJlZiIsImZvcndhcmRlZCIsImNvbm5lY3RfZGVmYXVsdCIsImNoaWxkcmVuIiwic2VydmVyU3RhdGUiLCJwcmV2aW91c1N0YXRlIiwiUHJvdmlkZXJfZGVmYXVsdCIsImNyZWF0ZVN0b3JlSG9vayIsInVzZVN0b3JlMiIsInVzZVN0b3JlIiwiY3JlYXRlRGlzcGF0Y2hIb29rIiwidXNlRGlzcGF0Y2gyIiwidXNlRGlzcGF0Y2giLCJiYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-redux/dist/react-redux.mjs\n',
      );

      /***/
    },
};
